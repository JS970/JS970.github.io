<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  
<title>운영체제 2023-03-27 수업정리 | Rounding Off</title>



<meta property="og:title" content="운영체제 2023-03-27 수업정리">



<meta name="author" content="JS970">


<meta property="og:locale" content="en-US">


<meta name="description" content="writing is much easier than remembering">
<meta property="og:description" content="writing is much easier than remembering">



<link rel="canonical" href="https://js970.github.io/unhyeonceje-3-27-suheojjeonri/">
<meta property="og:url" content="https://js970.github.io/unhyeonceje-3-27-suheojjeonri/">



<meta property="og:site_name" content="Rounding Off" />





  <meta property="og:type" content="article" />
  <meta property="article:published_time" content="2023-03-27T00:00:00+00:00">







  <meta name="twitter:card" content="summary">



  <meta property="twitter:title" content="운영체제 2023-03-27 수업정리">








<script type="application/ld+json">
{
  "author": {
    "@type":"Person",
	  "name":"JS970",
  },
  "description": "writing is much easier than remembering",
  "url": "https://js970.github.io/unhyeonceje-3-27-suheojjeonri/",
  "@context":"https://schema.org",
  "@type": "BlogPosting",
  "headline": "운영체제 2023-03-27 수업정리"
  
    
    
      "datePublished":"2023-03-27T00:00:00+00:00",
    
    "mainEntityOfPage":{
      "@type":"WebPage",
      "@id":"https://js970.github.io/unhyeonceje-3-27-suheojjeonri/"
    },
  
}
</script>

  <link rel="stylesheet" href="https://js970.github.io/main.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700">

  <link rel="icon" type="image/png" sizes="32x32" href="https://js970.github.io/assets/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://js970.github.io/assets/favicon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="https://js970.github.io/assets/apple-touch-icon.png">

  
    <link type="application/atom+xml" rel="alternate" href="https://js970.github.io/atom.xml" title="Rounding Off" />
  

  

  
  
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
	integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
	<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
	integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
	<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
	integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
	onload="renderMathInElement(document.body);"></script>

</head>

<body>
  
  <nav class="nav">
    <div class="nav-container">
      <a href="https://js970.github.io/">
        <h2 class="nav-title">Rounding Off</h2>
      </a>
      <ul>
        
          
            <li><a href="https://js970.github.io">Posts</a></li>
          
            <li><a href="https://js970.github.io/tags">Tags</a></li>
          
            <li><a href="https://js970.github.io/about">About</a></li>
          
        
      </ul>
    </div>
  </nav>
  

  <main>
    
  <div class="post">
  	<div class="post-info">
  		<span>Written by</span> JS970<br>
  		
  		<span>on&nbsp;</span><time datetime="2023-03-27">March 27, 2023</time>
  	</div>
  	<h1 class="post-title">운영체제 2023-03-27 수업정리</h1>
  	<div class="post-line"></div>
  	<h1 id="flow">Flow</h1>
<ul>
<li>IPC</li>
<li>IPC - Shared Memory</li>
<li>IPC - Message Passing</li>
<li>Examples of IPC Systems</li>
<li>Communications in Client-Server Systems</li>
</ul>
<h2 id="ipc">IPC</h2>
<hr />
<h3 id="ipc-inter-process-communication">IPC(Inter Process communication)</h3>
<ul>
<li>시스템에 속한 프로세스들은 independent일수도 있고, cooperating일수도 있다.</li>
<li>Reason for Cooperating Process
<ul>
<li>정보의 공유</li>
<li>계산속도 향상</li>
<li>모듈화</li>
<li>편의성</li>
</ul>
</li>
<li>cooperating프로세스들은 서로가 서로에게 영향을 끼친다.</li>
<li>IPC를 구현하는 방법으로는 아래와 같은 방법이 있다.
<ul>
<li>Shared Memory를 사용한 IPC구현
<ul>
<li>하나의 시스템을 사용중이므로 이러한 구조가 가능하다.</li>
<li>공유 메모리에 Process A, Process B모두 접근 가능하다.</li>
<li>이때 Process A, Process B는 모두 User Mode이다.</li>
</ul>
</li>
<li>Message passing을 통한 IPC구현
<ul>
<li>kernel영역에 속한 message queue를 사용해서 message를 전달하는 방식이다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="producer-consumer-problem">Producer-Consumer Problem</h3>
<ul>
<li>상호 작용하는 프로세스의 패러다임이다.</li>
<li>정보(데이터)를 생산하는 프로세스, 정보(데이터)를 소비(사용)하는 프로세스로 나누어 생각한다.</li>
</ul>
<h2 id="ipc-shared-memory">IPC - Shared Memory</h2>
<hr />
<p><img src="/image/OS/shared_memory.png" alt="Shared Memory" /></p>
<ul>
<li>Producer Process와 Consumer Process간의 공유 메모리를 사용하여 데이터를 전달한다.</li>
<li>이때 공유 메모리 내부에는 Buffer가 존재하는데, 이 버퍼는 unbounded혹은 bounded이다.
<ul>
<li>unbounded-buffer : 버퍼의 크기가 무제한(현실에서는 불가능)</li>
<li>bounded-buffer : 유한한 크기의 버퍼 사용</li>
</ul>
</li>
<li>Shared Memory방식의 IPC는 User Mode의 두 프로세스 사이에서만 일어난다.(Not the Operating Systems)</li>
<li>이러한 메커니즘의 구현에 있어 동기화 issue가 존재한다.
<ul>
<li>producer process가 데이터 생성을 하지 않았는데 consumer process가 접근하는 경우 등</li>
<li>위 동기화 문제를 해결하더라도 producer와 consumer중 &quot;누가 먼저 시작할 것인가?&quot; 라는 issue가 남아있다.</li>
<li>이러한 issue는 instruction 단위 동기화를 필요로 하며, 아래는 Shared data, Producer Process, Consumer process에서 이러한 동기화 문제를 반영한 코드의 예시이다.</li>
<li>Shared data<pre data-lang="C" style="background-color:#2b303b;color:#c0c5ce;" class="language-C "><code class="language-C" data-lang="C"><span style="color:#b48ead;">#define </span><span>BUFFER_SIZE </span><span style="color:#d08770;">10
</span><span style="color:#b48ead;">typedef struct </span><span>{
</span><span>...
</span><span>} item;
</span><span>
</span><span>item buffer[BUFFER_SIZE];
</span><span style="color:#65737e;">// 데이터 삽입 인덱스
</span><span style="color:#b48ead;">int</span><span> in = </span><span style="color:#d08770;">0</span><span>;
</span><span style="color:#65737e;">// 데이터 출력 인덱스
</span><span style="color:#b48ead;">int</span><span> out = </span><span style="color:#d08770;">0</span><span>;
</span></code></pre>
</li>
<li>Producer Process<pre data-lang="C" style="background-color:#2b303b;color:#c0c5ce;" class="language-C "><code class="language-C" data-lang="C"><span>item nextProduced;
</span><span style="color:#b48ead;">while</span><span>(</span><span style="color:#d08770;">true</span><span>) {
</span><span>	</span><span style="color:#65737e;">// 버퍼가 가득 차 있는 상태 -&gt; 대기
</span><span>	</span><span style="color:#b48ead;">while</span><span>(((in+</span><span style="color:#d08770;">1</span><span>) % BUFFER_SIZE) == out) ;
</span><span>	</span><span style="color:#65737e;">// 버퍼가 가득 차 있지 않다면 다음 데이터 버퍼에 적재
</span><span>	buffer[in] = nextProduced;
</span><span>	</span><span style="color:#65737e;">// 버퍼 삽입 이후 버퍼 삽입 인덱스를 증가시킨다.
</span><span>	in = (in+</span><span style="color:#d08770;">1</span><span>) % BUFFER_SIZE;	
</span><span>}
</span></code></pre>
</li>
<li>Consumer Process<pre data-lang="C" style="background-color:#2b303b;color:#c0c5ce;" class="language-C "><code class="language-C" data-lang="C"><span>item nextConsumed;
</span><span style="color:#b48ead;">while</span><span>(</span><span style="color:#d08770;">true</span><span>) {
</span><span>	</span><span style="color:#65737e;">// 버퍼가 비어 있는 상태 -&gt; 대기
</span><span>	</span><span style="color:#b48ead;">while</span><span>(in == out) ;
</span><span>	</span><span style="color:#65737e;">// 버퍼가 비어 있지 않다면 출력 버퍼를 읽어온다.
</span><span>	nextConsumed = buffer[out];
</span><span>	</span><span style="color:#65737e;">// 출력 이후 버퍼 출력 인덱스를 증가시킨다.
</span><span>	out = (out+</span><span style="color:#d08770;">1</span><span>) % BUFFER_SIZE;
</span><span>}
</span></code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="ipc-message-passing">IPC - Message Passing</h2>
<p><img src="/image/OS/message_passing.png" alt="Message Passing" /></p>
<ul>
<li>Message를 주고 받는 식으로 두 프로세스 간의 공유 자원 없이 이루어진다.</li>
<li>이때 kernel이 중계자 역할을 하여 프로세스 간 메시지를 전달한다.<img src="/image/OS/message_passing_2.png" alt="Message Passing 2" /></li>
<li>이렇듯 Message Passing을 위해서는 두 개의 method를 제공해야 한다.
<ul>
<li>send(msg)</li>
<li>receive(msg)</li>
</ul>
</li>
<li>프로세스 P, 프로세스 Q간의 Message Passing 방식의 통신을 위해서는
<ol>
<li>P와 Q간의 communication link를 활성화 해야 한다.(논리적 통로)</li>
<li>논리적 통로가 제공하는 send(), receive()를 이용해 논리 통로를 이용한다.</li>
</ol>
</li>
<li>Message Passing의 Implementation Issue로는 아래와 같은 것들이 있다. 전부 구현 단계에서 고민할 문제이다(Implementation Issues).
<ul>
<li>communication link는 어떻게 개설되는가?</li>
<li>두 개 이상의 프로세스에 대해서 link의 활성화가 가능한가?</li>
<li>각 쌍의 communicating processes애 대하여 얼마나 많은 communication link의 개설이 허용되는가?</li>
<li>communication link의 capacity는 어떻게 되는가?</li>
<li>전달되는 message의 크기는 고정 크기인가 가변 크기인가?</li>
<li>communication link를 통한 message passing은 단방향인가 양방향인가?</li>
</ul>
</li>
</ul>
<h3 id="direct-communication">Direct Communication</h3>
<ul>
<li>Direct Communication에서는 Producer Process와 Consumer Process가 서로를 직접 호출(명시적 호출) 하여 message를 주고받는다.
<ul>
<li>send(P, message) - send a message to process P</li>
<li>receive(Q, message) - receive a message from process Q</li>
<li>위와 같이 send, receive의 호출에 있어 explicit 하게 동작한다.</li>
</ul>
</li>
</ul>
<h3 id="indirect-communication">Indirect Communication</h3>
<ul>
<li>Indirect Communication 에서는 mailbox를 이용한다. 이는 Port개념과 유사하다.
<ul>
<li>각각의 mailbox는 unique id를 가진다.</li>
<li>프로세스들은 오직 서로가 mailbox를 공유할 때만 통신 가능하다.(같은 Port에서 통신 가능하다)</li>
<li>communication link역시 각 프로세스가 공통의 mailbox를 공유할 때만 개설 가능하다.</li>
<li>communication link는 여러 프로세스 간에 참조 가능하다.</li>
<li>각각의 프로세스 쌍들은 수 개의 communication link를 공유한다.</li>
<li>이때, link는 단/양방향 모두 될 수 있다.</li>
</ul>
</li>
<li>Indirect Communication을 지원하기 위해서는 아래와 같은 operation들을 지원해야 한다.
<ul>
<li>create a new mailbox</li>
<li>send, receive</li>
<li>destroy mailbox</li>
</ul>
</li>
<li>Indirect Communication방식으로 Message Passing을 구현할 때, 아래와 같은 issue가 발생한다.<img src="/image/OS/message_passing_issue.png" alt="Indirect Communication Issue" />
<ul>
<li>P1, P2, P3가 mailbox M을 공유한다.</li>
<li>P1은 producer process, P2, P3는 consumer process이다.</li>
<li><strong>이때 P2, P3중 누가 message를 수신해야 하는가?</strong></li>
</ul>
</li>
<li>위 issue의 해결 방법으로 아래와 같은 해결책이 있다. 하지만 기본적으로, 이러한 issue는 모두 구현에 따른다(Implementation Issues)
<ul>
<li>최대 두 개의 프로세스 간에만 communication link가 개설되도록 제한한다.</li>
<li>receive operation을 두 프로세스가 동시에 수행할 수 없도록 제한한다.</li>
<li>임의적으로(arbitrarily) 선택되는 것을 허용한다.</li>
</ul>
</li>
</ul>
<h3 id="synchronization">Synchronization</h3>
<ul>
<li>Message Passing 방식은 Blocking방식 또는 Non-Blocking방식으로 동작한다.</li>
<li>Blocking - Considered synchronous
<ul>
<li>blocking send는 message가 도착할 때까지 sender block을 가지고 있는다.</li>
<li>blocking receive는 message가 전송 가능할 때까지 receiver block을 가지고 있는다.</li>
<li>기본적으로 non-blocking방식보다 overhead가 클 수밖에 없다. 하지만 message를 주고(sned) 받는(receive)과정에서의 동기화 문제에 대해 자유롭다.</li>
</ul>
</li>
<li>Non-Blocking - Considered asynchronous
<ul>
<li>non-blocking send는 그냥 계속해서 message를 send한다.</li>
<li>non-blocking receive는 vaild message와 null을 구분하지 않고 계속해서 receive한다.</li>
</ul>
</li>
<li>send, receive모두 blocking방식일 경우 rendezvous(랑데뷰)라고 한다.</li>
<li>Blocking, Non-Blocking방식 모두 각각의 장점이 있으며, application에 따라 알맞은 방식으로 구현하면 된다.</li>
</ul>
<h3 id="buffering">Buffering</h3>
<ul>
<li>Communication Link의 Message Queue는 다음 세 가지 중 하나의 버퍼링 방식으로 message를 처리한다.
<ul>
<li>Zero capacity - 0 messages
<ul>
<li>sender 는 receiver를 항상 기다려야 한다(rendezvous)</li>
</ul>
</li>
<li>Bounded capacity - n개의 유한한 크기의 메시지를 들고 있을 수 있다.(일반적인 경우)
<ul>
<li>message queue가 full이라면 sender는 무조건 대기해야 한다.</li>
</ul>
</li>
<li>Unbounded capacity - infinite length
<ul>
<li>엄밀하게는 현실에서 불가능하다. 하지만 충분한 양의 메시지를 저장 가능하다면, 이 방식으로 분류한다.</li>
<li>sender는 절대 기다리지 않는다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="examples-of-ipc-systems">Examples of IPC Systems</h2>
<hr />
<ul>
<li>Windows의 advanced local procedure call(LPC)의 동작에 관해서 살펴보자<img src="/image/OS/LPC_Windows.png" alt="LPC" />
<ol>
<li>클라이언트가 connection port를 통해 server로 connection 요청을 한다.</li>
<li>Server는 두 개의 Private Communication Port를 생성하고, 그 중 하나에 대한 제어권을 client에게 양도한다.</li>
<li>Client와 Server는 각자의 port를 사용하여 Shared Section Object에 접근 가능하다.(공유 버퍼)</li>
</ol>
</li>
</ul>
<h2 id="communications-in-client-server-systems">Communications in Client-Server Systems</h2>
<hr />
<h3 id="sockets">Sockets</h3>
<ul>
<li>네트워크 통신에서의 endpoint</li>
<li>host X : 146.855.5.20:1625 &lt;-&gt; web server : 161.25.19.8:80
<ul>
<li>포트(1625, 80)를 이용해 Communication Establishment가 가능하다.
<ul>
<li>여기서 port number는 mailbox의 unique id와 대응된다.</li>
</ul>
</li>
<li>Communication Establishment되었으므로 socket통신이 일어난다.</li>
</ul>
</li>
</ul>
<h3 id="remote-procedure-call">Remote Procedure Call</h3>
<ul>
<li>네트워크 시스템에서 떨어져 있는 프로세스를 호출하는 과정은 아래와 같다.<img src="/image/OS/RPC.png" alt="RPC" />
<ul>
<li>Client에서는 Stub Code를 사용하여 함수 호출에 필요한 값들을(인자 값, 함수 명 등) marshall한다.
<ul>
<li>marshalling이란 표현 방식을 전송에 적합한 방식으로 변환하는 과정이다.</li>
</ul>
</li>
<li>Server의 Stub Code는 메시지를 전달받고, unmarshall한다. 그리고 server에서 전달받은 값들을 사용하여 프로세스를 호출한다.</li>
</ul>
</li>
<li>RPC의 사용을 통해 원격에 존재한 client - server에서 IPC가 가능해 진다.</li>
</ul>
<h3 id="pipes">Pipes</h3>
<ul>
<li>마치 파이프처럼 두 프로세스 간 통신을 수행한다.<img src="/image/OS/pipe.png" alt="Pipe" />
<ul>
<li>P1의 결과를 P2가 (pipe를 통해)전달받아 사용한다.</li>
</ul>
</li>
<li>Pipe구현 시 고려할 점
<ul>
<li>Unidirectional or Bidirectional?</li>
<li>Half duplex or Full duplex?</li>
<li>Relationship(부모 프로세스 - 자식 프로세스 등)</li>
<li>Environment(네트워크 환경에서의 구현인지, 아니면 같은 시스템 내의 구현인지)</li>
</ul>
</li>
<li>Pipe의 두 종류
<ul>
<li>Ordinary Pipes
<ul>
<li>파이프를 생성한 프로세스 이외에서는 해당 파이프에 접근 불가능하다.</li>
<li>보통은 부모 프로세스가 파이프를 생성해서 자식 프로세스와의 통신에 사용한다.</li>
<li>통신에 참여하는 두 프로세스가 producer-consumer관계이다.(unidirectional)</li>
<li>producer는 파이프의 한쪽 구멍을 통해 write한다.</li>
<li>consumer는 파이프의 나머지 한쪽 구멍을 통해 read한다.</li>
<li>파이프를 사용한 통신이 종료되면 ordinary pipe는 사라진다.</li>
</ul>
</li>
<li>Named Pipes
<ul>
<li>부모-자식 프로세스 관계가 아니더라도 접근 가능하다.</li>
<li>양방향 구현이 가능하다(bidirectional).</li>
<li>일반적으로 유닉스 또는 윈도우 시스템에서 제공되는 형태이다.</li>
</ul>
</li>
</ul>
</li>
<li>Pipe와 Message Passing의 차이점
<ul>
<li>Message Passing은 Mailbox를 통해 서로 다른 타입의 값에 대해서도 전달이 가능하다.
<ul>
<li>서로 다른 타입의 message를 linked list형태로 message queue에 저장한다.</li>
<li>즉, 서로 다른 자료구조에 대해 처리가 가능하다.</li>
</ul>
</li>
<li>Pipe는 기본적으로 Bytestream(혹은 bitstream)단위로 전달되기 때문에 타입에 대한 정의 자체가 없다. 따라서 서로 다른 타입에 대해서는 처리할 수 없다.</li>
</ul>
</li>
</ul>

  </div>

	

  <div class="pagination">
  	
		<a href="#" class="top">Top</a>
		
  </div>

  </main>

  
  <footer>
    <span>&copy; 2022 JS970. Made with <a href="https://www.getzola.org">Zola</a> using the <a
          href="https://github.com/aaranxu/tale-zola">Tale-Zola</a> theme.</span>
  </footer>
  
</body>
</html>
