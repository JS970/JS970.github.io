+++
title = "프로그래밍언어론 2023-05-11 수업정리"
date = 2023-05-11
[taxonomies]
tags = ["Programming Language Principles"]
[extra]
author = "JS970"
katex= true
+++
# Flow
- Primitive Types : Others
- Character String
- User-defined ordinal type
- Array types
- Lua(1)

## Primitive Types : Others
---
- 주로 business application에서 사용되는 type이다.
- 1282같은 숫자를 이진수로 표현하는 것이 아닌, 각 자리를 fixed number로 표현한다.
	- 0~9까지 10개의 숫자를 표현해야 하므로 4비트가 필요하다
	- 4비트를 사용하면 16개를 표현할 수 있는데 10개밖에 표현 못하므로 메모리가 낭비된다.

## Character String
---
### Design issues
- 배열의 일종으로 볼 수도 있고(C), primitive type으로 볼 수도 있다(C++).
- 길이가 가변적인지, 고정적인지 생각해야 한다.
	- `FORTRAN`, `Ada`, `COBOL`은 static length를 가진다.
	- `C`, `C++`, `PL/I`은 limited dynamic하게 배열의 크기를 가진다.
	- `SNOBOL4`의 경우 dynamic한 배열의 크기를 가진다.

### Implementation of string
- c의 경우 String은 Character String이므로, 길이를 구하기 위해 배열을 순회해야 한다.
- str.length()가 for 문 안에서 사용되었다면 nested loop이므로 O(n)이 아닐 수 있음에 유의
- 이 때문에 가장 앞 비트에 크기를 저장하는 인코딩을 사용하기도 한다.

## User-Defined Ordinal Types
---
### Ordinal Type
- 0또는 양의 정수를 포함하는 범위의 집합
- 서수(순서)로 사용된다.
- `integer`, `character`, `boolean`은 Ordinal Type이다.

### Cardinal Type
- 기수(값, 양)로 사용된다.

### User-Defined Ordinal Type
- Enumeration Type
- Subrange Type
	- `readablilty`, `reliability`의 관점에서 pros가 있다.
	- `realiability`의 경우 범위를 초과했을 경우 컴파일 타임의 검사가 가능하다.

## Array Types
---
- composite type이다.

### Design issues
- Subscript Type & range checking
- The Maximum Number of Subscripts
	- `C`, `C++` 은 1차원 배열을 가진다. 즉, A\[i]\[j] 같은 방식으로 다차원 배열을 구현한다.
	- `BASIC`, `FORTRAN`의 경우 A\[i, j]와 같은 다차원 배열 접근을 지원한다.

### Array Categories
- Static
	- `FORTRAN`
- Fixed Stack-dynamic
- Stack-dynamic
- Heap-dynamic
	- `java`

### Conformant Arrays
- Open Arrays와 상반되는 개념이다.
- `BASIC`, `Pascal`에서는 index range가 type의 일부였다. 아래의 두 배열은 서로 다른 타입이다.
```Pascal
VAR
    MyArray1 : ARRAY [1..10] OF INTEGER;
    MyArray2 : ARRAY [1..20] OF INTEGER;
```
- 이에 불편함을 느껴 Conformant array의 개념이 등장하였다.
	- 아래의 `C`코드에서 두 배열은 서로 같은 타입이다.
```C
int MyArray1[10];
int MyArray2[20];
```
- 처음 살펴봤던 `Pascal`에서도 ISO Standard에 따른 Conformant array를 지원한다.
- 아래는 `Pascal`의 conformant array이다.
```Pascal
PROCEDURE MyProc(VAR x : ARRAY [low..high : INTEGER] OF INTEGER);
```

### Reference
[Stack Overflow - What is a Conformant Array?](https://stackoverflow.com/questions/8482318/what-is-a-conformant-array/33085128#33085128?newreg=ac58357844b94ad9af567a633c2b1b58)

## Lua(1)
---
### About Lua
- 단순하고 쉬운 구문을 가진다.
- `Python`과 유사하지만 들여쓰기 언어는 아니다.(인덴트 무시해도 됨)
- 속도 역시 `Python`과 비교했을 때 훨씬 빠른 편이다.
	- Hybrid implementation방식을 채택하였다.
- 동적 타입 언어이며 garbage collection을 통한 자동 메모리 관리 기능이 있다.
- ANSI C로 작성되었으며, 엔진이 공개되어 있다.

### Env Setting
- [Download Page](http://www.lua.org/download.html)
- At Terminal(Mac tested)
	- 별도의 환경 변수 설정을 할 필요는 없다.
```bash
curl -R -O http://www.lua.org/ftp/lua-5.4.4.tar.gz
tar -zxf lua-5.4.4.tar.gz
cd lua-5.4.4
make all test
```
- Visual Studio에서 작업하는 것을 권장한다. 아래 확장 프로그램을 설치해서 사용한다.
	- Code Runner(필수)
	- Lua, Lua Debug(Optional

### Data Types
- `nil` : null과 같은 표현이다. 초기 `LISP`에서 사용되었던 표현이다.
- `boolean` : false and true
- `number` : 정수와 부동소수점 모두 `number`타입이다.
- `string` : 문자열
- `table` : 연관 배열(Pythond의 dictionary 유사함)
- 아래와 같이 `type()`메소드를 사용하여 타입을 확인 가능하다.

### Operators
- 본 절에서는 다른 언어와 비슷한 표현은 넘어가고, `Lua`의 특이한 표현만 기술한다.
- 더 자세한 정보는 [Download Page](http://www.lua.org/download.html)에서 다운받은 파일을 압축 해제하여 README.md를 읽어보자.
- 비교 연산자
	- `~=` : 다른 언어에서의 `!=`과 같은 표현이다.
- 산술 연산자
	- `^` : 거듭제곱을 연산하는 산술 연산자이다.
- 논리 연산자
	- `and`, `or`, `not` : 그대로의 의미를 가진다.
	- `nil`과 `false`를 모두 '거짓'으로 판단한다.
	- 이때 먼저 위치한 타입을 따른다.
	```Lua
	nil and false
	false and nil
	```
	- 위 코드의 첫 번째 문장을 실행하면 `nil`, 두 번째 문장을 실행하면 `false`를 출력한다.
- 조건 연산자
	- `and`, `or`를 조합하여 아래와 같이 사용한다.
	```Lua
	max = (x > y) and x or y
	```
- String Operators
	- `..`을 사용하여 String concatenation이 가능하다.
	- `sub`메소드를 사용하여 string을 자를 수 있다.
	```Lua
	s = "hello"
	s:sub(1, 2)
	```
	- 위 코드를 실행시킨 결과는 he이다.
- 대입 연산자
	- 다중 대입 연산을 지원한다.
	- 필드 개수가 안 맞으면 남는 값은 버린다. 대입의 경우에 개수가 남으면 `nil`로 설정된다.
	```Lua
	a, b, c = 0, 1
	print(a, b, c)

	x, y = 0, 1, 2
	print(x, y)
	```
	- 위 코드를 실행시킨 결과는 0, 1, `nil`이고, 아래의 코드를 실행시킨 결과는 0, 1이다.

### Scope
- 기본적으로 모든 변수는 global variable이다.
- 지역 변수를 사용하려면 키워드 `local`을 사용해야 한다.

### Control Structure
- `if`, `else` 구문은 아래 코드처럼 마지막에 `end`키워드를 사용해야 한다.
```Lua
if a<b then return a else return b end
```
- `while`, `for`구문 역시 마지막에 `end`키워드를 사용해야 한다.
- `while`, `for`구문의 사용 예시는 아래와 같다.
```Lua
while condition do statement end

for variable=start, end increasement_state do statement end
```
