+++
title = "운영체제 2023-04-24 수업정리"
date = 2023-04-24
[taxonomies]
tags = ["Operating System"]
[extra]
author = "JS970"
katex= true
+++
# Flow
- Peterson's Solution

## Peterson's Solution
---
> 운영체제 4.12 수업에서 이어짐

### Peterson's Solution
- 고전적인 critical section problem의 software-based solution이다.
- LOAD/STORE 명령어는 atomic operation임이 전제이다.
	- atomic operation이므로 다른 명령어에 의해 LOAD/STORE동작이 방해받지 않는다.
- 두 개의 공유 변수를 사용한다.
	- turn : critical section에 진입할 차례인 process를 나타낸다.
		- 별도의 초기화를 하지 않는다.(전역 변수이므로 0으로 초기화됨)
	- flag : 두 개의 프로세스에 대해 critical section에 진입할 준비가 끝났음을 의미한다.
		- flag\[i\]는 0또는 1의 값을 가진다.(0 : 아직 준비가 안됨, 1 : 진입 준비 완료)
		- flag\[0\], flag\[1\]은 false로 초기화된다.(어떤 프로세스도 진입할 준비가 안됨)
- 각 프로세스는 기본적으로 양보하는 동작을 취한다.
	1. 자신이 준비됨
	2. 상대의 turn으로 turn변수의 값을 변경
	3. 상대가 준비되지 않은 상태임이 확인되면 critical section진입
	4. critical section이 종료된 후 자신의 flag를 FALSE로 변경
```C
/* Process i */
do {
	flag[i] = TRUE;
	turn = j;
	while(flag[j] == TRUE && turn == j);
	
	/* Critical Section */
	
	flag[i] = FALSE;
	
	/* Remainder Section */
} while(TRUE)
```
- critical section을 공유하는 또 다른 프로세스 j의 코드
```C
/* Process j */
do {
	flag[j] = TRUE;
	turn = i;
	while(flag[i] == TRUE && turn == i);
	
	/* Critical Section */
	
	flag[j] = FALSE;
	
	/* Remainder Section */
} while(TRUE)
```

### Peterson's Solution의 증명
- 아래의 1, 2, 3을 통해 Peterson's Solution이 Valid Critical Section임이 증명된다.
1. Mutual Exclusion(상호배제조건) 검사 : 어떠한 두 프로세스도 critical section에 동시에 진입할 수 없다.
	- 프로세스 i가 critical section으로 진입하기 위한 조건
		- (flag\[i\] == TRUE) && (flag\[j\] == FALSE) && (turn == i)
		- (flag\[i\] == TRUE) && (flag\[j\] == FALSE) && (turn == j)
		- (flag\[i\] == TRUE) && (flag\[j\] == TRUE) && (turn == i)
	- 프로세스 j가 critical section으로 진입하기 위한 조건
		- (flag\[j\] == TRUE) && (flag\[i\] == FALSE) && (turn == j)
		- (flag\[j\] == TRUE) && (flag\[i\] == FALSE) && (turn == i)
		- (flag\[j\] == TRUE) && (flag\[i\] == TRUE) && (turn == j)
	- 위의 모든 경우를 살펴보았을 때, 프로세스 i와 j가 동시에 critical section으로 진입 가능한 경우의 수는 존재하지 않는다. 따라서 Peterson's Solution 은 Mutual Exclusion조건을 만족한다.
		- (flag\[i\] == TRUE) && (flag\[j\] == FALSE)인 조건에서는 프로세스 j가 critical section에 진입할 수 없다.
		- (flag\[j\] == TRUE) && (flag\[i\] == FALSE)인 조건에서는 프로세스 i가 critical section에 진입할 수 없다.
		- (flag\[j\] == TRUE) && (flag\[i\] == TRUE) && (turn == j) && (turn == i)인 경우는 존재할 수 없다.
2. Progress(진행조건) 검사 : critical section에 진입한 프로세스가 없는 상태에서, critical section으로 진입하고자 하는 프로세스는 어떠한 지연도 없이 critical section으로 진입이 가능해야 한다.
	- 프로세스 i의 입장에서 아래 상황에 대해 생각해 보자.
		- (flag\[j\] == FALSE)라면, 프로세스 i는 critical section으로 진입이 가능하다.
		- (flag\[j\] == TRUE)이고, (turn == j)라면, 프로세스 i는 while루프에서 대기하게 된다. 하지만 critical section에 진입한 프로세스가 없다면 프로세스 j의 코드에 의해 (trun == i) 이다. 
		- 따라서 critical section에 진입한 프로세스가 없다면 프로세스 i는 while문을 수행하지 않고 곧바로 critical section으로 진입이 가능하므로 Progress조건을 만족한다.
3. Bounded waiting 검사 : critical section에 진입을 대기하는 프로세스는 유한시간 대기 후 진입이 보장되어야 한다.
	- Bounded waiting조건은 얼마나 기다리는지는 중요하지 않다. N개의 프로세스가 있다면 최소 N-1번의 프로세스 실행 이후에는 대기 중인 프로세스가 실행이 보장되어야 한다는 조건이다.
	- 프로세스 i의 입장에서 (flag\[j\] == TRUE) && (turn == i)인 상황에 대해 생각해 보자
		- (flag\[i\] == TRUE)라면, 프로세스 i는 critical section으로 진입한다.
		- (flag\[i\] == FALSE)라면, 프로세스 j가 critical section으로 진입한다.
			- 이 경우 프로세스 j가 실행된 이후 프로세스 i의 실행이 보장된다.
	- 따라서 Peterson's Solution은 Bounding waiting조건 역시 만족한다.
