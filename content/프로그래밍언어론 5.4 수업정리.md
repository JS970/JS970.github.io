+++
title = "프로그래밍언어론 2023-05-04 수업정리"
date = 2023-05-04
[taxonomies]
tags = ["Programming Language Principles"]
[extra]
author = "JS970"
katex= true
+++
# Flow
- SWI-Prolog(3)

## SWI-Prolog(3)
---
### Unification and Computation
- Prolog에서는 unification중 computation이 일어난다.
- unification : 동형화, 패턴 매칭을 통해 목표를 탐색한다.
- computation : 계산, is/2 술어(predicate)를 통해 수행된다.
- 값을 계산하기 위해 술어`is` 를 사용해야 하는 것에 주의하자.
	- 대입 연산자`=`를 사용할 경우 Prolog는 연산하지 않고 그대로 값을 보여준다.
	```Prolog
	sun([], 0).
	sum([H|T], S) :-
		sum(T, S1), S = H + S1. 
	```
	- 실행 결과 아래와 같이 연산을 하지 않고 출력한다.![predecate test](/image/PL/isPredecateTest.png)

### Tail Recursion
Prolog에서의 tail recursion(꼬리 재귀)에 대해 알아보자.
- 아래 코드는 계산 결과값을 저장하는 변수의 연산이 이뤄지는 부분에서 재귀만 있다고 볼 수 없으므로 꼬리 재귀가 아니다.(M is N * M1)
```Prolog
fact(0, 1).
fact(N, M) :-
	N > 0,
	N1 is N - 1,
	fact(N1, M1),
	M is N * M1.
```
- 아래 코드는 factorial을 계산하는 Prolog 프로그램을 tail recursion으로 구현한 것이다.
```Prolog
fact(0, M, M).
fact(N, Acc, F) :-
	N > 0,
	N1 is N - 1,
	Acc1 is Acc * N,
	fact(N1, Acc1, F).
```
- 실행 결과(무려 100!까지 문제없이 구한다)![Prolog Tail Recursion Factorial](/image/PL/tailFactorialProlog.png)

### Tail Recursion과 연산 순서
앞서 `is`대신에 `=`을 사용하면 연산(calculation)하지 않고 그대로 출력한다고 했다. 이를 이용해서 연산 순서 및 결합 방향에 대해 알아보자.
- 아래는 배열 원소들의 합을 구하는 sum합수이다.
```Prolog
sum([], 0).
sum([H|T], S) :-
	sum(T, S1),
	S is H + S1.
```
- 위 코드의 `is`를 `=`으로 수정하였을 경우 결과는 아래와 같다.![predecate test](/image/PL/isPredecateTest.png)
- 아래는 같은 프로그램을 tail recursion으로 구현한 코드이다.
```Prolog
sum([], Si, Si).
sum([H|T], Si, So) :- 
	NextSi is H + Si,
	sum(t, NextSi, So).
```
- 위 코드의 `is`를 `=`으로 수정하였을 경우의 결과는 아래와 같다.![tailAssign](/image/PL/tailAssign.png)
- tail recursion의 경우 5, 4, 3, 2, 1순서로, 그냥 recursion의 경우 1, 2, 3, 4, 5순서로 연산이 수행되었다.

### 4 Port Model of Prolog Execution
![Four Port Model](/image/PL/fourPortModel.png)
- 위 그림은 Prolog의 프로그램이 실행되는 상태 전이 모형을 나타낸 것이다.
- `Call` port : 프로그램이 처음 호출되었을 때 사용되는 포트
- `Exit` port : 프로그램이 진행되어 실행이 종료될 때 사용되는 포트
- `Fail` port : 프로그램 실행 중 완전히 실패(failure)한 경우 사용되는 포트
- `Redo` port : failure한 경우 다른 정답을 찾으려 시도할 때 사용되는 포트
- [reference](https://alsprolog.com/docs/guide/14-Using-the-Four-Port-Debugger.html)

### Enable Debugging
- trace/0 : 모든 포트에서 정지하도록 설정함
- notrace/0 : 정지 설정을 끈다.
- debug/0 : 디버깅 모드를 활성화한다.
- nodebug/0 : 디버깅 모드를 종료한다.

### Debugging Example
- 아래의 에러가 있는 코드를 디버깅해보자
```Prolog
isEven(2).
isEven(X) :-
	Y is X - 2,
	isEven(Y).
```
- isEven(4). 실행 결과 모든 포트에서 문제 없이 동작하는 것을 확인 가능하다.![isEven(4) Nobug](/image/PL/noBugDebugging.png)
- isEven(5). 실행 결과 프로그램이 종료되지 않는 것을 확인 가능하다.![isEven(5) Bug](/image/PL/isEven5Bug.png)
- bug를 수정하기 위해 fail/0을 사용하여 홀수에 대한 처리를 해주자.
```
isEven(1) :-
	fail.
isEven(2).
isEven(X) :-
	Y is X - 2,
	isEven(Y).
```
- 하지만 여전히 종료되지 않고 계속 실행되는 것을 확인할 수 있다.![isEven(5) Bug2](/image/PL/isEven5BugRedo.png)
- 이는 fail을 유도하지 않는 다른 정답에 대해 계속 탐색하기 때문이다. 따라서 `cut`을 사용해 되추적을 중단시켜야 버그가 완전히 해결된다. `cut`은 `!`으로 표기한다.
```Prolog
isEven(1) :-
	!, fail.
isEven(2).
isEven(X) :-
	Y is X - 2,
	isEven(Y).
```
- 아래는 수정한 프로그램의 실행 결과이다. 5는 짝수가 아니므로 false를 출력한다.![isEven(5) No Bug](/image/PL/isEven5NoBug.png)

### N-Queen's Problem with Prolog
- 다른 프로그래밍 언어에 비해 매우 간단하게 문제를 해결할 수 있다.
- 아래는 N-Queen's Problem을 해결하는 코드이다.
```
queens(N, Qs) :-
	range(1, N, Ns),
	permutation(Ns, Qs),
	safe(Qs).

safe([]).
safe([Q|Qs]) :- 
	safe(Qs), 
	not(attack(Q, Qs)).

attack(X, Xs) :- 
	attack(X, 1, Xs).

attack(X, N, [Y|_]) :- 
	X is Y + N; X is Y - N.
attack(X, N, [_|Ys]) :- 
	N1 is N+1, 
	attack(X, N1, Ys).

range(N, N, [N]).
ragne(M, N, [M|Ns]) :- 
	M < N, 
	M1 is M + 1, 
	range(M1, N, Ns).
```
- 아래는 4 x 4, 6 x 6에서의 N-Queen's Probolem의 답을 구하기 위해 프로그램을 수행한 결과이다.![NQueens Prolog](/image/PL/nqueensProlog.png)
