+++
title = "프로그래밍언어론 2023-05-16 수업정리"
date = 2023-05-16
[taxonomies]
tags = ["Programming Language Principles"]
[extra]
author = "JS970"
katex= true
+++
# Flow
- Review
- Array
- Open array
- Associative array
- Record
- Union
- Pointer

## Review
---
- 변수는 속성과 binding된다.
	- binding이 프로그램 실행 중에 일어나면 `dynamic binding`이다.
	- binding이 프로그램 실행 전에 일어나면 `ststic binding`이다.
- 속성은 이름, 타입, 값, 주소, 지속시간, 가시영역이다.
	- 가시 영역에 따라 참조 환경이 달라진다.
	- 이전 시간부터 이 속성들 중 타입에 대해 공부했다.
- 타입은 아래와 같은 기준으로 분류된다.
	- Fundamental type vs Derived type
	- Atomic(Scala) type vs Composit type
	- Primitive(built - in) type vs User - defined type
		- 이 기준은 언어에 따라 다르다.
- 타입 분류 예시
	- Fundemental & Atomic type : `int`, `float`
	- Fundemantal & Composit type : `complex`, `String(C++)`
	- Derived & Atomic type : `enum`, `subrange`, `pointer`
	- Derived & Composit type : `array`, `record`

## Array
---
### Array operations
- FORTRAN 90(이 버전만)
	- element-wise array operations지원
	- Intrinsic functions for array operations
		- matrix multiplication
		- matrix transpose
		- vector dot product
	- Slice
		- row slice, column slice
		- MAT(1:4, 1)과 같이 사용
- APL
	- 많은 Array operation을 지원한다.
	- reverse the column(row)지원
	- transpose
	- inverse
	- inner product
	- element summation
- Ada
	- single dimension array에서 연속된 원소들에 대한 slice지원
	- string에 대한 slice(substring reference라고 한다.)

### Implementation of Arrays
- Compile Time Descriptor
	- array descriptor를 사용한다.
	- descriptor는 lower bound, upper bound등 배열에 대한 정보를 가진 벡터이다.
	- 이를 `dope vecotor`라고 부른다. 검사용 벡터라는 뜻이다.
- 첨자(index)를 통해 주소(address)에 접근하는(mapping) access function을 가진다.
	- 이때 언어에 따라 row major, column major 구현 방법이 나뉜다.
	- 사실 대부분의 언어는 행우선으로 구현된다. 
	- FORTRAN은 Array를 열우선으로 구현한 대표적인 언어이다.
	- C언어 예시
		```C
			int a[2][3] = { {1, 2, 3},
							{4, 5, 6},
							{7, 8, 9}};
		```
		- C언어는 대표적인 행우선(row major) 언어이다.
		- a\[0\] = {1, 2, 3}이므로 a\[0\]\[0\], a\[0\]\[1\], a\[0\]\[2\]는 차례대로 1, 2, 3이다.
		- 이처럼 열을 우선적으로 순회한다.
	- 열우선의 경우 아래와 같이 구현한다.
		```Fortran
			location(matrix[i,j])
				= (address of matrix[1, 1]) + ((i-1)*n + (j-1)) * (element size)
					= A + B*i + C*j
		```

## Open Array
---
- range가 따로 type에 포함되지 않는 array이다.
- conformant array가 ISO표준이지만, 이미 ISO제정 이전에 open array로 설계된 언어가 있다(Pascal)
- 배열이 전달될 때 lower bound는 소실된다.
- high라는 function을 사용하여 upper bound 값이 얻어진다.
- Pascal에서 a : Array of 3..7이라고 선언하면 a\[3\] ~ a\[7\]에 접근이 가능하다.
	- 하지만 이 배열을 인자로 넘기게 되면 lower bound는 소실되고 a\[1\]부터 a\[5\]로 접근하게 된다.
	- 이때 a\[5\]의 upper bound는 function high를 통해 얻어진다.
- C/C++ 의 배열도 open array의 일종으로 볼 수 있다.(인자 전달 시 크기값을 따로 전달하므로)
	- C++의 경우 C++11에서 Array타입을 새로 만들었다.(conformant array)
- Java의 배열도 유사하지만, Java의 배열은 객체이다.
	- function high대신 length라는 field를 가진다.

## Associative Arrays
---
- 정렬되지 않은 elements의 집합
- elements는 key값에 의해 정렬된다.
- 이때 element와 key를 Hashing functinon을 통해 매핑한다.

### Design Issues
- elements의 reference형태
- 배열의 크기를 dynamic으로 할지, static으로 할지
- Perl에서는 Hash, Python에서는 dictionary, Lua에서는 table이다.

## Records
---
### Array vs Record
- Array : homogenous aggregation, index를 통해 접근
- Record : heterogenous aggregation, name 을 통해 접근

### Design Issues
- reference의 형태를 어떻게 할지
- elliptical reference(모호한 참조)를 허용할지

> 이외에도 수업시간에 COBOL의 record에 대한 operations, reference에 대해 다루었으니 강의자료 참고

## Union
---
### Record vs Union
- recorddml field들은 서로 다른 위치에 저장된다.
- Union은 field의 크기만큼 최대 메모리에서 할당한다.
- Union을 variant record(가변 record)로 보기도 한다.

### Design Issues
- type checking을 위해 tag를 사용하기도 한다.
	- Algol 68에서는 `conformity clauses`를 사용했을 때만 reference가 가능하다.
	- Pascal에서는 tag값 각각에 대한 assign이 가능하다. 이 때문에 type checking에 문제가 있다.
	- Ada에서는 Constraint variant record, Unconstrained variant record를 모두 지원한다.
		- Constraint variant record의 경우 variant type이 바뀔 수 없다.
		- Unconstraint variant record의 경우 Pascal처럼 variant type이 바뀔 수 있다.
- union을 record의 일종으로 보아야 하는지에 대해 고려해야 한다.

## Pointer
---
- C에서 처음 포인터 개념을 도입하기 전에 이미 Pascal, Algol에서 포인터 개념은 사용되었다.
- 포인터는 addressing에 flexibility를 증가시키기 위해 사용되며, 동적 메모리 관리를 담당한다.
- 함수할당을 포인터로 하기도 한다.

### Design Issues
- 포인터 변수의 lifetime
- 동적 할당된 변수의 lifetime
- 명시적 포인터(C, C++), 암시적(reference) 포인터(Java, C++)

### Problems with pointeres
- Dangling Pointers
	- 허상 포인터
	- 존재 자체로 문제이며 위험하다.
	- 메모리 해제 과정에서 문제가 된다. 따라서 delete가 없는 java에서는 문제가 되지 않는다.
- Lost Heap-Dynamic variable
	- 분실 객체
	- garbage라고도 한다.
	- 크게 위험하다기 보다는 메모리 낭비의 원인이 된다.

### Handling Dangling Pointers
- Tombstome 사용
	- 포인터가 메모리를 해제하면 Tombstone(비석)이 이 메모리는 죽었다고 표시하여 다른 포인터가 참조하지 못하도록 한다.
- Locks-and-Keys
	- 모든 포인터는 ordered pair로 존재한다(key, address).
	- key값이 0이면 invalid이다.
- 두 방법 모두 검사가 필요하므로 성능 면에서 비효율적이다.