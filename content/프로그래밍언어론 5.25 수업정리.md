+++
title = "프로그래밍언어론 2023-05-25 수업정리"
date = 2023-05-25
[taxonomies]
tags = ["Programming Language Principles"]
[extra]
author = "JS970"
katex= true
+++
# Flow
- Side-Effect
- Overloading
- Type Conversion
- Lua - File I/O
- Lua - Closures
- Lua - Iterator
- Lua - Coroutine

## Side-Effect
---
- 부수효과 또는 부대효과 라고도 한다.
- 값 계산 외에 참조 환경 등이 다르게 변경되는 효과이며, 프로그램 수행 결과를 예측하기 힘들게 한다.
	- 함수가 부수효과를 발생시킨다면, 연산자의 계산 순서에 따라 값이 달라질 수 있다.
- 함수의 부수효과는 비지역 변수, 인수 전달, I/O로 인해 발생 가능하다.

### Side-Effect문제 해결 방법
1. 함수의 부수효과를 발생시킬 수 없도록 한다.
	- 입출력 인수를 허용하지 않는다.
	- 비지역 변수 참조를 허용하지 않는다.
	- 하지만 입출력 인수, 비지역 변수의 사용이 필요한 경우가 있으므로 이 방법으로는 완전히 해결 불가능하다.
2. 모든 연산자의 피연산자 계산순서를 고정시킨다.
	- Java에서 사용하는 방법이다.
	- 연산 계산 순서를 정확히 예측할 수 있다는 장점이 있다.
	- 일부 컴파일러 최적화를 수행할 수 없다는 단점이 있다.
3. 함수의 부수효과를 검사한다.
	- FORTRAN77에서 사용하는 방법이다.
	- 함수 호출이 어떤 식에 포함될 경우에는, 해당 함수가 부수효과를 일으키지 않는 경우에만 맞는 것으로 간주한다.
	- 항상 가능하지 않다. False positive가 많이 발생한다.
		```C
			int a = 7;
			int zero() { return a-a; }
		```
	- 위 코드는 부수효과를 발생시키지 않지만, 부수효과 검사 과정에서는 부수효과가 있다고 판단할 수 있다.

## Overloading
---
- 하나의 이름에 여러 기능을 부여하는 것을 말한다.
- 일반적으로 사칙연산자에 대해 Overloading을 한다.

### 연산자 중복지정의 위험성
- 컴파일러 오류 검사가 힘들다.
	- C언어에서 아래와 같은 코드에 대해 생각해 보자.
		```C
		a = & b;
		```
	- 이 코드에서 사용된 `&` 연산자가 단항연산자에서의 주소 연산자인지, 이항연산자에서의 bitwise연산자인지 알 수 없으므로 컴파일러에 의한 오류 검사가 힘들다.
	- 마찬가지로 C++에서의 아래와 같은 코드를 생각할 수 있다.
		```C++
		vector<vector<int>> vec;
		```
		- `>>` 에서 컴파일러가 오류를 발생시킬 수 있다.

### 연산자 중복저정의 장점
- 코드가 간결해 진다.
- 이러한 장점 때문에 연산자 중복지정을 허용하는 언어로 아래와 같은 언어들이 있다.
	- C++
	- Ada
	- FORTRAN 90
	- Python

## Type Conversion
---
- 축소변환(narrowing conversion)과 확장변환(widening conversion)이 있다.
	- 축소변환 : 원래 타입의 모든 값을 포함하지 못하는 형으로의 변환
	- 확장변환 : 원래 타입의 모든 값을 포함하는 형으로의 변환
- 묵시적 타입변환(implicit type conversion) : `type coercion`
	- 타입 오류 검출 능력이 저하된다는 단점이 있다.
	- 대부분의 언어에서 수치 자료의 확장변환에 대해서만 제한적으로 허용한다.
	- Lua에서는 묵시적 형 변환을 채택하고 있다.
- 명시적 타입변환(explicit type conversion) : `type casting`
	- 확장변환, 축소변환을 모두 허용한다.
	- 일반적으로 축소변환의 경우 경고 메시지를 발생시킨다.
- 혼합 자료형 표현식(mixed-mode expression)에서 형 변환을 필요로 한다.

## Lua - File I/O
---
- 파일을 모드 문자열에 지정된 대로 여는 방법(file open)
	```Lua
	handle = io.open(fileName, MODE)
	```
- 기본 입력 혹은 출력을 handle로 바꾼다.(file set)
	```Lua
	io.input(handle), io.output(handle)
	```
- 파일을 닫는다.(file close)
	```Lua
	io.close(handle)
	```

### input
- 문자열을 입력받아 반환
	```Lua
	io.read()
	```
- 수를 입력받아 반환
	```Lua
	io.read("*n")
	```
- 한 행을 입력받아 반환
	```Lua
	io.read("*1")
	```
- 파일 내 모든 데이터를 입력받아 반환
	```Lua
	io.read("*a")
	```

### output
- 데이터를 출력함
	```Lua
	pirnt(data)
	```
- 파일의 맨 끝 행에 출력한다. print와 달리 개행문자를 출력하지 않는다.
	```Lua
		io.write(data)
	```

## Lua - Closure
---
![Closure](/image/PL/closure.png)
- 참조 환경과 함수를 묶은 것을 `Closure` 라고 한다.
- 언제든지 함수를 계산할 수 있는 형태이다.
- 람다 함수는 참조 환경이 없는 클로저라고 볼 수 있다.

### Closure Example
```Lua
-- closure
print("=================================")
print("Closure Example")
print("=================================")
function newCounter()
    local i = -1
    return function() i = i + 1 return i end
end
 
c1 = newCounter()
for i = 1, 10 do print(c1()) end
```
- 람다 함수와 참조 환경(i)로 이루어진 newCounter가 반환하는 값이 `Closure`이다.

## Lua - Iterator
---
- 어떤 자료 구조의 모든 자료를 훑는 함수를 반복자(iterator)라고 한다.
- Lua에서는 `Closure`를 이용하여 반복자를 작성할 수 있다.

### Iterator Example
```Lua
--Iterator Example using closure
print("=================================")
print("Iterator Example using closure")
print("=================================")
function iterator(t)
    local i, sz = 0, #t
    return function()
        i = i + 1
        if i <= sz then return t[i] end
    end
end
 
for n in iterator({10, 20, 30, 40}) do print(n) end
for n in iterator({"Hello", "Lua"}) do print(n) end
```
- local i는 0으로, sz는 인수로 전달받은 컨테이너의 크기로(#t) 초기화한다.
- 실행할 때마다 i가 1씩 증가하면서 i가 컨테이너의 사이즈보다 크지 않을 때까지 모든 컨테이너를 순회한다.
- 이렇게 closure로 구현된 iterator는 실행할 때마다 배열의 index를 한칸씩 옮겨가며 원소값을 출력한다.

## Lua - Coroutine
---
- 자신만의 수행 상태를 지니고 있는 함수를 `Coroutine`이라고 부른다.
- 이전 상태를 기억한다는 측면에서 과거 인식 함수와 유사하다.
- 자신만의 수행 상태가 유지된다는 측면에서 Thread와 유사하다.
	- 하지만 Thread와 달리 concurrency를 지원하지는 않는다.
	- 한번에 하나씩 실행된다.
	- 유사병행성(quasi-concurrency)을 구현하는데 사용된다.

### Coroutine status
- `Coroutine`수행 상태를 유지하기 위해 몇 가지 상태 중 하나에 놓이게 된다.
- `suspended` : 코루틴이 생성되었으나 실행되고 있지 않은 상태
- `running` : 코루틴이 실행 중인 상태
- `dead` : 코루틴의 본체가 모두 수행되어 종료된 상태

### Coroutine의 특징
- Symmetric vs Asymmetric
	- 통상적인 코루틴은 symmetric이 성립한다. 즉, 호출자와 피호출자가 구별되지 않아야 한다.
	- Lua의 코루틴은 호출자와 피호출자가 구별된다는 측면에서 asymmetric이다.
- Coroutine vs Threads
	- 수행 상태를 지니고 있다는 점에서 코루틴과 Thread는 비슷하다.
	- 그러나 Thread는 실제로 병렬로 수행될 수 있다는 점에서 코루틴과 다르다.
	- 이런 한게로 인해 코루틴을 이용한 병렬성을 `유사병렬성` 이라고 부른다.
- Coroutine vs Iterator
	- 반복자도 상태를 지니고 있다는 점에서 코루틴과 유사한 면이 있다.
	- 그러나 코루틴은 반복자보다 더 다양한 상태에 있을 수 있으므로 반복자보다 강력하다.

### Coroutine Example
```Lua
--Coroutine
print("=================================")
print("Coroutine Example")
print("=================================")
cntdown = coroutine.create(function()
    coroutine.yield(5)
    coroutine.yield(4)
    coroutine.yield(3)
    coroutine.yield(2)
    coroutine.yield(1)
end)
 
repeat
    state, cnt = coroutine.resume(cntdown)
    print(cnt == nil and "Blast!!" or cnt, state)
until coroutine.status(cntdown) == "dead"
 
state, cnt = coroutine.resume(cntdown)
print(cnt, state)
```
- `coroutine.create`를 통해 코루틴을 생성한다.
- `coroutine.yield`를 통해 코루틴을 실행한다(사실상 return의 역할을 수행한다)

