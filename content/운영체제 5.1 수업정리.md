+++
title = "운영체제 2023-05-01 수업정리"
date = 2023-05-01
[taxonomies]
tags = ["Operating System"]
[extra]
author = "JS970"
katex= true
+++
# Flow
- Classical Problems - Readers and Writers Problem
- Classical Problems - Philosophers Problem
- Monitor
- etc

## Classical Problems - Readers and Writers Problem
---
- Concurrent processes 간에 Data set이 공유되고 있다고 하자.
	- Readers : **only read** the data set, don't perform any updates
	- Writers : can both **read and write** the data set

### Problem
- 동시에 여러 Readers가 읽는 동작을 수행하는 것을 허용한다. 
- 하지만 오직 하나의 writer만 shared data에 접근 가능하다.
- 이에 따른 shared data에 대한 접근 제어가 필요하다.

### Semaphores & Shared data
- readcount : 몇 개의 reader 프로세스가 data set을 read하고 있는지 count
- mutex : 초기값은 1로 설정되며, readcount가 업데이트 될 때의 mutual exclusion을 보장한다.
- wrt : 초기값은 1로 설정되며, writer의 mutual exclusion을 보장한다.(writer가 1개일 때는 의미x)

### Readers and Writers Problem Solution
- Writer code
```c
do {
	wait(wrt);
	// writing is performed
	signal(wrt);
} while(TRUE)
```
- Reader code
```c
do {
	// readcount에 대한 mutual exclusion
	wait(mutex);
	readcount++;

	// 첫 번째 reader의 경우 데이터가 쓰여졌는지 확인해야 한다.
	if(readcount == 1) wait(wrt);
	
	// reading is performed

	// readcount에 대한 mutual exclusion
	signal(mutex);
	readcount--;

	// 마지막 reader의 경우 writer가 쓸 수 있는 상태임을 알려줘야 한다.
	if(readcount == 0) signal(wrt);
	
	signal(mutex);
} while(TRUE)
```
- 본 단에서 설명한 코드들은 writer process가 하나인 경우에 대한 solution이다.

## Classical Problems - Dining-Philoosophers Problem
---
- 식사하는 철학자 문제(출처 : 위키피디아)![Dining Philosophers Problem](/image/OS/dining_philosophers.png)
- 굉장히 큰 규모의 concurrent process의 동시제어가 필요한 상황에 대해 다룬다.
- 문제 설명
	- 다섯 명의 철학자가 원탁에 앉아 있고, 음식을 먹기 위해서는 양 옆의 젓가락을 동시에 들어야 한다.
	- 이때 바로 옆의 사람이 음식을 먹기 위해서는 본인이 젓가락을 내려 놓아야 하는 상황이다.
	- 다섯 명 모두가 서로를 기다리는 deadlock상태에 빠질 수 있다.
- chopstick을 semaphore로, philosophers를 process라고 생각하자.
	- 젓가락의 사용 여부를 mutex로 0/1로 표현한다.(초기값은 1로 설정된다.)
	- 규칙을 tough하게 설정하여 deadlock이 발생하지 않도록 만들어야 한다.

## Monitor
---
- philosophers problem과는 다른 방법으로 deadlock문제를 해결한다.
- Java에서 제공하는 high-level abstract data type이다.
	- process synchronization을 위해 하나의 프로세스만 monitor를 통해 활성화되도록 한다.
- 동작![Monitor](/image/OS/monitor.png)
	- 모티너 내부의 프로시저들이 순차적으로 실행된다.
	- condition variable을 사용한다.(그림에서의 x와 y)
	- condition variable에 대한 wait(), signal()메소드를 제공한다.
		- wait : 어떤 프로세스를 대기 상태로 변경
		- signal : 대기 상태에서 다시 resume
- 아래 코드의 프로지저(P1, P2, P3 ... )는 한 번에 하나만 실행 가능하다.
	```java
	monitor monotor_name {
		// shared variable declaration
		procedure P1(...) {...}
		
		procedure P2(...) {...}
		
		procedure P3(...) {...}
	
		...
	}
	```

## etc..
---
- 앞서 설명한 방법들 이외에도 critical section문제를 해결하기 위해 아래와 같은 방법들이 존재한다.

### Linux Provides
- semaphore
- atomic integers
- spinlocks
- reader-writer versions of both

### etc
- 이외에도 많은 솔루션들이 존재하니 찾아보자.
