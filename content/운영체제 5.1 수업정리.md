+++
title = "운영체제 2023-05-01 수업정리"
date = 2023-05-01
[taxonomies]
tags = ["Operating System"]
[extra]
author = "JS970"
katex= true
+++
# Flow
- Classical Problems - Readers and Writers Problem
- Classical Problems - Philosophers Problem
- Monitor
- etc
- Deadlock - Deadlock conditions

## Classical Problems - Readers and Writers Problem
---
- Concurrent processes 간에 Data set이 공유되고 있다고 하자.
	- Readers : **only read** the data set, don't perform any updates
	- Writers : can both **read and write** the data set

### Problem
- 동시에 여러 Readers가 읽는 동작을 수행하는 것을 허용한다. 
- 하지만 오직 하나의 writer만 shared data에 접근 가능하다.
- 이에 따른 shared data에 대한 접근 제어가 필요하다.

### Semaphores & Shared data
- readcount : 몇 개의 reader 프로세스가 data set을 read하고 있는지 count
- mutex : 초기값은 1로 설정되며, readcount가 업데이트 될 때의 mutual exclusion을 보장한다.
- wrt : 초기값은 1로 설정되며, writer의 mutual exclusion을 보장한다.(writer가 1개일 때는 의미x)

### Readers and Writers Problem Solution
- Writer code
```c
do {
	wait(wrt);
	// writing is performed
	signal(wrt);
} while(TRUE)
```
- Reader code
```c
do {
	// readcount에 대한 mutual exclusion
	wait(mutex);
	readcount++;

	// 첫 번째 reader의 경우 데이터가 쓰여졌는지 확인해야 한다.
	if(readcount == 1) wait(wrt);
	
	// reading is performed

	// readcount에 대한 mutual exclusion
	signal(mutex);
	readcount--;

	// 마지막 reader의 경우 writer가 쓸 수 있는 상태임을 알려줘야 한다.
	if(readcount == 0) signal(wrt);
	
	signal(mutex);
} while(TRUE)
```
- 본 단에서 설명한 코드들은 writer process가 하나인 경우에 대한 solution이다.

## Classical Problems - Dining-Philoosophers Problem
---
- 식사하는 철학자 문제(출처 : 위키피디아)![Dining Philosophers Problem](/image/OS/dining_philosophers.png)
- 굉장히 큰 규모의 concurrent process의 동시제어가 필요한 상황에 대해 다룬다.
- 문제 설명
	- 다섯 명의 철학자가 원탁에 앉아 있고, 음식을 먹기 위해서는 양 옆의 젓가락을 동시에 들어야 한다.
	- 이때 바로 옆의 사람이 음식을 먹기 위해서는 본인이 젓가락을 내려 놓아야 하는 상황이다.
	- 다섯 명 모두가 서로를 기다리는 deadlock상태에 빠질 수 있다.
- chopstick을 semaphore로, philosophers를 process라고 생각하자.
	- 젓가락의 사용 여부를 mutex로 0/1로 표현한다.(초기값은 1로 설정된다.)
	- 규칙을 tough하게 설정하여 deadlock이 발생하지 않도록 만들어야 한다.

## Monitor
---
- philosophers problem과는 다른 방법으로 deadlock문제를 해결한다.
- Java에서 제공하는 high-level abstract data type이다.
	- process synchronization을 위해 하나의 프로세스만 monitor를 통해 활성화되도록 한다.
- 동작![Monitor](/image/OS/monitor.png)
	- 모티너 내부의 프로시저들이 순차적으로 실행된다.
	- condition variable을 사용한다.(그림에서의 x와 y)
	- condition variable에 대한 wait(), signal()메소드를 제공한다.
		- wait : 어떤 프로세스를 대기 상태로 변경
		- signal : 대기 상태에서 다시 resume
- 아래 코드의 프로지저(P1, P2, P3 ... )는 한 번에 하나만 실행 가능하다.
	```java
	monitor monotor_name {
		// shared variable declaration
		procedure P1(...) {...}
		
		procedure P2(...) {...}
		
		procedure P3(...) {...}
	
		...
	}
	```

## etc..
---
- 앞서 설명한 방법들 이외에도 critical section문제를 해결하기 위해 아래와 같은 방법들이 존재한다.

### Linux Provides
- semaphore
- atomic integers
- spinlocks
- reader-writer versions of both

### etc
- 이외에도 많은 솔루션들이 존재하니 찾아보자.

## Deadlock - Deadlock conditions
---
- 프로세스는 한정적인 resource를 사용한다. 이때 다른 프로세스가 사용중인 resource를 요구할 수 있다.
- 이 때 발생하는 문제에 대해 좀 더 직관적으로 살펴보기 위해 system model관점에서 살펴보자.

### System Model
- 시스템은 resource로 구성된다.
	- 이 resource들은 Resource Type으로 분류한다.(R1, R2, R3, ... , Rm)
	- 각 Resource Type들은 CPU cycle, Memory space, I/O devices등 자원 타입을 의미한다.
- Resource Type Ri는 Wi개의 instance를 가질 수 잇다.
	- 자원 종류별로 사용 가능한 instance개수가 제한된다.(진짜 자원, 객체 개념으로 생각하자)
- 프로세스들은 아래와 같은 과정으로 resource를 사용한다.
	- Request(자원 요청)
	- Use(자원 사용)
	- Release(자원 반납)

### deadlock
- A set of blocked processes each holding a resource and waiting to acquire a resource held by another process in the set
- 두 개의 프로세스가 자원을 보유한 상태로 상대방의 자원을 request하고 있는 상황이 deadlock이다.
- **결국 자원을 release하지 않으면서** 다른 프로세스에 의해 점유된 resource를 held하고 있는 것이 deadlock의 원인이다.
- deadlock을 해결하기 위해서는 held하고 있는 자원을 release하면 된다.
- 다음 장에서 설명할 deadlock condition **4가지 조건을 동시에 만족하면** deadlock이 발생할 **가능성이 있다**고 본다.(can arise deadlock)

### Deadlock conditions
- 아래의 1, 2, 3, 4번 조건을 모두 만족한다면 deadlock이 발생할 가능성이 있다고 본다.
1. Mutual Exclusion
	- 하나의 프로세스만 하나의 자원을 사용할 수 있는 상황이다.(semaphore 등)
2. Hold and Wait
	- 다른 프로세스에서 hold되어진 자원을 요청하고 이를 기다리는 상황이다.
3. No Preemption
	- resource가 오직 resource를 hold하고 있는 프로세스의 release를 통해서만 회수된다.
4. Circular Wait
	- 프로세스 간 순환 구조를 형성하면서 대기중이다.
	- P1 -> P2 -> P3 -> P4 -> P1

### Resource Allocation Graph
![Allocation Graph Consistents](/image/OS/allocation_graph_consistents.png)
- 그래프의 vertices는 두 가지 타입으로 구성된다
	- process(P0, P1, ..., Pm) : m개의 프로세스가 존재
	- resource(R0, R1, ..., Rn) : n개의 resource가 존재
- 그래프의 edge 역시 두 종류가 있다.
	- Request Edge : directed edge Pi -> Rj
	- Assignment Edge : directed edge Rj -> Pi

### Resource Allocation Graph Example1(No Deadlock)
![Resouurce Allocation Graph Example(No Deadlock)](/image/OS/resourceAllocationGraphNoDeadlock.png)
- R1, R2, R3, R4는 mutex조건(mutual exclusion)을 만족한다고 가정하자.
	- 위 그래프만으로는 알 수 없다.
- hold and wait
	- P1은 R2를 hold하고 있으며 R1을 request하고 있다.
	- P2는 R1을 hold하고 있으며 R3를 request하고 있다.
	- P3의 경우 R3를 hold하고 있지만 resource를 request하고 있지 않다.
- No Preemption조건 역시 그래프만으로는 확인할 수 없으므로 만족한다고 가정하자.
- Circular Wait
	- circular wait을 만족하지 않는다.
	- P1 -> R1 -> P2 -> R3 -> P3, R2 -> P2

### Resource Allocation Graph Example2(Deadlock)
![Resource Allocation Graph with Deadlock](/image/OS/resourceAllocationGraphDeadlock.png)
- R1, R2, R3, R4는 mutual exclusion 조건을 만족한다고 가정하자.
- Hold and Wait
	- P1, P2, P3모두 해당된다.
- No Preemption조건을 만족한다고 가정하자.
- Circular Wait조건을 만족한다.
	- P1 -> R1 -> P2 -> R3 -> P3 -> R2 -> P1(P2)
- 네 가지 조건을 만족하기 때문에 deadlock이 존재할 수 있고, 실제로도 있다.
	- 네 가지 조건을 만족해도 deadlock이 없을 수 있다. 아래의 예시를 보자.

### Resource Allocation Graph Example3(No Deadlock)
![No Deadlock with deadlock conditions](/image/OS/resourceAllocationGraphCircleNoDeadlock.png)
- 위 그래프는 deadlock condition의 네 가지 조건을 모두 만족한다. 
- 하지만 실제로 deadlock은 발생하지 않는다.
- 이는 P4(또는 P2)가 자원을 release하면 P3가 R2에 접근하면서 Circular Cycle이 깨지게 된다.
- cycle은 P1과 P3가 형성하지만 P2, P4에 의해 cycle이 깨질 수 있으므로 deadlock이 발생하지 않는다.
- 결국 Resource Allocation Graph를 통해서 확실히 알 수 있는 정보는 cycle유무를 통해 deadlock이 없다는 것을 확실히 할 수 있다는 것이다.


