+++
title = "운영체제 2023-05-03 수업정리"
date = 2023-05-03
[taxonomies]
tags = ["Operating System"]
[extra]
author = "JS970"
katex= true
+++
# Flow
- Deadlock Handling - Deadlock Prevention
- Deadlock Handling - Deadlock Avoidance
- Deadlock Handling - Enter a deadlock state and then recover

## Deadlock Handling - Deadlock Prevention
---
- deadlock condition중 최소 한 가지 이상의 조건을 만족하지 않도록 설정하여 deadlock을 예방하는 방법
- Computational Overhead가 너무 커서 실제로 사용하지는 않는다.
- 본 절에서는 방법론에 대해서만 다룬다.

### Mutual Exclusion
- shared resources를 require하지 않고 nonsharable resource만 hold하는 방법으로 구현한다.
- 일반적으로 Mutual Exclusion을 부정하는 방법으로는 deadlock prevent를 할 수 없다.
	- 일부 자원의 경우 애초부터 non-sharable이기 때문

### Hold and Wait
- 어떤 프로세스든 자원을 request할 때는 어떠한 resource도 hold하지 않는 것을 보장한다.
- 오버헤드가 너무 크다.(Low resource utilization문제가 있다)
- starvation이 발생할 가능성이 있다.

### No Preemption
- 어떤 프로세스가 자원을 holding하고 있으면서 request할 때, 곧바로 할당받는 것이 아니라 모든 resource를  release한 후에 자원을 할당받는다.
- 프로세스는 모든 자원을 확보한 후에야 실행 가능하다.
	- 결과적으로 한번의 request를 통해 필요한 자원을 확보애햐 한다
- Preemptive동작을 하는 것과 동일한 효과이다.

### Circular Wait
- waiting이 circular cycle을 형성하지 않도록 한다.
- process, resource가 increasing order로만 request가능하도록 설정한다.
- P3는 P1이 점유중인 자원에 대해 request할 수 없는 rule을 만들어서 구현하는 방식이다.

## Deadlock Handling - Deadlock Avoidance
---
- Deadlock Avoidance를 구현하기 위해서 시스템은 아래와 같은 사전 정보를 필요로 한다.
	- Resource currently available
	- The resources currently allocated to each process
	- The future requests and releases of each process
- Deadlock Avoidance는 앞서 설명한 사전 정보들을 이용해서 circular-wait condition을 형성하는 자원 할당이 이루어지지 않도록 dynamically examines하는 알고리즘이다.