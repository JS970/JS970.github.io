+++
title = "컴퓨터 알고리즘 2023-04-24 수업정리"
date = 2023-04-24
[taxonomies]
tags = ["Computer Algorithm"]
[extra]
author = "JS970"
katex= true
+++
# Flow
- Greedy Algorithm
- Sapnning Tree
- Prim's Algorithm
- Kruskal's Algorithm

## Greedy Algorithm
---
- Greedy Algorithm은 "순간순간 선택의 시점마다 항상 그 상황에서 최선인 선택을 하는" 알고리즘이다.
- 아래는 Greedy Algorithm의 예시이다.
	>10원, 50원, 100원, 500원 동전이 무한 개 있다. 코인의 개수를 가장 적게 선택하여 730원을 지불하려면 어떻게 해야 하는가?
- 이를 해결하기 위해서는 동전의 선택 시점마다 항상 선택 가능한 동전 중 금액이 가장 큰 동전을 선택하면 된다.

### Greedy Algorithm vs Dynamic Programming
- 두 알고리즘 모두 최적화 문제를 풀기 위해 사용된다.
- Greedy Algorithm의 경우 한번 선택된 사항에 대해 재고하지 않는다.
- Greedy Algorithm의 선택은 이전 선택이나 이후 선택에 영향을 받지 않는다.
- Greedy Algorithm의 경우 Locally Optimal하다.
	- 따라서 Locally Optimal함이 반드시 증명되어야 한다.

### Greedy Approach
1. Selection procedure : 현재 상태에서 최선의 해답을 선택한다.
2. Feasibility Check : 선택된 해가 문제의 조건을 만족하는지 확인한다.
3. Solution Check : 원래 문제가 해결되었는지 검사하고, 해결되지 않았다면 1~3을 반복한다.

## Spanning Tree(신장 트리)
---
- G = (V, E)인 undirected weighted graph이다.
- V = {v1, v2, v3, v4, v5}
- E = {(v1, v2), (v1, v3), (v2, v4), (v3, v4), (v3, v5), (v4, v5)}
- W : 각 edge의 weight값
- Spanning Tree는 Graph G의 모든 Vertices를 포함하는 Subgraph이다.

### Minimum Spanning Tree
- G = (V, E), T = (V, F)인 undirected graph G, T가 있다. 이때  F가 E의 부분집합일 때 F의 weight 값의 합이 최솟값을 가지는 spanning tree를 Minimum Spanning Tree라고 한다.

## Prim's Algorithm
---
1. 그래프에서 하나의 꼭짓점을 선택한다.
2. 꼭짓점과 edge를 구성하는 vertex중 edge의 weight이 가장 작은 vertex를 선택한다.
3. 2에서의 vertices와 edge를 구성하는 vertex중 edge의 weight이 가장 작은 vertex를 선택한다.
4. 더 이상 선택되지 않은 vertex가 없을 때까지 1~3을 반복한다.
![Prim's Algorithm](/image/Algorithm/Prim.png)

### Code
```C++
/* Code by https://4legs-study.tistory.com/m/112 */
#include <iostream>
#include <vector>
#include <algorithm>
#include <queue>
 
using namespace std;
 
typedef pair<int, int> p;
// number of vertex
int v = 6;
// adj[1][2][2] : e(1, 2), w = 2
vector<p> adj[7];
// check array
bool visit[7];
 
struct compare {
    bool operator()(p a, p b) {
        return a.second > b.second;
    }
};
 
void Prim() {
    // 큐 안의 간선들은 가중치 기준 오름차순으로 항상 정렬된다.
    priority_queue<p, vector<p>, compare> pque;
 
    // 출발지와 연결된 간선들을 모두 큐에 삽입
    for (int i = 0; i < adj[1].size(); i++) pque.push(adj[1][i]);
    visit[1] = true;
 
    int cnt = 0;
    // 정점의 개수 - 1만큼 반복한다.
    while(cnt < v - 1) {
        // 큐 안의 간선들 중 가중치가 가장 작은 간선을 큐에서 빼낸다.
        p curline = pque.top();
        pque.pop();
 
        // node, weight값을 curline의 값으로 갱신
        int node = curline.first;
        int weight = curline.second;
 
        // 뽑은 간선의 목적지 노드가 이미 발견된 상태라면 선택하지 않음
        if (visit[node]) continue;
        // 방문 노드 표시
        visit[node] = true;
        cnt++;
 
        // 현재 간선을 MST에 추가
        printf("%d번 정점 발견 : 비용 %d\n", node, weight);
 
        // 뽑은 간선의 목적지 노드와 연결된 간선들을 모두 큐에 삽입
        for(int i = 0; i < adj[node].size(); i++) {
            int nextnode = adj[node][i].first;
            if(!visit[nextnode]) pque.push(adj[node][i]);
        }
    }
}
 
// Graph Initialization
void init() {
    adj[1].push_back(make_pair(2, 9));
    adj[1].push_back(make_pair(3, 4));
    adj[1].push_back(make_pair(4, 3));
    adj[1].push_back(make_pair(5, 1));
 
    adj[2].push_back(make_pair(1, 9));
    adj[2].push_back(make_pair(4, 4));
    adj[2].push_back(make_pair(5, 5));
 
    adj[3].push_back(make_pair(1, 4));
    adj[3].push_back(make_pair(6, 6));
 
    adj[4].push_back(make_pair(1, 3));
    adj[4].push_back(make_pair(2, 4));
    adj[4].push_back(make_pair(5, 2));
    adj[4].push_back(make_pair(6, 8));
 
    adj[5].push_back(make_pair(1, 1));
    adj[5].push_back(make_pair(2, 5));
    adj[5].push_back(make_pair(4, 2));
 
    adj[6].push_back(make_pair(3, 6));
    adj[6].push_back(make_pair(4, 8));
}
 
int main() {
    init();
 
    printf("[MST]\n");
    Prim();
 
    return 0;
}
```

### Every-Case Time Complexity of Prim's Algorithm
- Input Size : n
- 서로 connection이 없는 vertex의 edge weight는 무한대로 초기화된다.
- Basic operation : n-1회 반복하는 반복문 내부에 각각 n-1회 반복하는 2개의 for loop이 존재한다.
	- n-1회 반복하는 반복문 : 시작 vertex를 제외한 모든 vertex에 대해 탐색
	- n-1회 반복하는 for문-1 : 모든 vertex중 가장 weight이 작은 vertex 탐색
	- n-1회 반복하는 for문-2 : 선택되지 않은 vertex의 weight 갱신
$$T(n) = 2 \times (n-1) \times (n-1) \in \Theta(n^2)$$
### Reference
[MST - Prim code](https://4legs-study.tistory.com/m/112)

## Kruskal's Algorithm
---
1. 그래프의 개별 노드로 구성된 V개의 subset을 생성한다.
2. edge들을 weight에 따라 오름차순으로 정렬한다.
3. edge를 선택했을 때 두 개의 서로 다른 V를 연결한다면, 해당 edge를 final edge set에 추가시키고, 두 V를 merge 한다.(이제 두 subset은 하나의 집합으로 인식한다.)
4. subset의 집합이 하나만 남을 때까지 3을 반복해서 수행한다.
- 다음 그래프에 대해 Kruskal Algorithm을 적용해 보자.                            ![Example Graph](/image/Algorithm/graph_ex1.png)
	- 위에서 설명한 과정을 차례대로 수행하면 아래 그림과 같다.![Kruskal Algorithm](/image/Algorithm/kruskal.png)

### Code
```C++
#include <iostream>
#include <vector>
#include <algorithm>
 
using namespace std;
 
// Union-Find 자료구조를 위한 클래스
class UnionFind {
private:
    vector<int> parent;
    vector<int> rank;
 
public:
    UnionFind(int n) {
        parent.resize(n);
        rank.resize(n, 0);
        for(int i = 0; i < n; i++) parent[i] = i;
    }
 
    int find(int x) {
        if(parent[x] != x)
            parent[x] = find(parent[x]);
        return parent[x];
    }
 
    void unite(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if(rootX != rootY) {
            if(rank[rootX] < rank[rootY])
                parent[rootX] = rootY;
            else if (rank[rootX] > rank[rootY])
                parent[rootY] = rootX;
            else {
                parent[rootY] = rootX;
                rank[rootX]++;
            }
        }
    }
};
 
// 간선을 나타내는 클래스
class Edge {
public:
    int src, dest, weight;
 
    Edge(int src, int dest, int weight) {
        this->src = src;
        this->dest = dest;
        this->weight = weight;
    }
};
 
bool compare (const Edge& a, const Edge& b) {
    return a.weight < b.weight;
}
 
// Kruskal 알고리즘으로 최소 신장 트리를 구하는 함수
vector<Edge> kruskalMST(vector<Edge>& edges, int V) {
    // 간선을 가중치의 오름차순으로 정렬
    sort(edges.begin(), edges.end(), compare);
 
    vector<Edge> result; // 최소 신장 트리를 저장할 벡터
    UnionFind uf(V); // Union-Find 자료구조 객체
 
    for(const Edge& edge : edges) {
        int srcRoot = uf.find(edge.src);
        int destRoot = uf.find(edge.dest);
 
        // 사이클을 형성하지 않는다면 간선을 추가하고 Union-Find자료구조를 업데이트
        if(srcRoot != destRoot) {
            result.push_back(edge);
            uf.unite(srcRoot, destRoot);
        }
    }
 
    return result;
}
 
int main() {
    int V, E;
    cout << "정점 개수와 간선 개수를 입력하세요: ";
    cin >> V >> E;
 
    vector<Edge> edges;
    cout << "간선 정보를 입력하세요 (출발 정점, 도착 정점, 가중치):" << endl;
    for (int i = 0; i < E; i++) {
        int src, dest, weight;
        cin >> src >> dest >> weight;
        edges.emplace_back(src, dest, weight);
    }
 
    vector<Edge> mst = kruskalMST(edges, V);
 
    cout << "최소 신장 트리의 간선 정보:" << endl;
    for (const Edge& edge : mst) {
        cout << edge.src << " - " << edge.dest << " : " << edge.weight << endl;
    }
 
    return 0;
}
```

### Kruskal vs Prim
- Kruskal Algorithm의 경우 모든 edge를 정렬하는 과정이 필요하다. 이때 정렬에 걸리는 시간복잡도는 mlogm이다.
- 모든 vertex가 연결된 n개의 정점을 가지는 그래프의 경우 n(n-1)/2개의 edge를 가질 수 있다.
- 따라서 kruskal algorithm의 worst case는 아래와 같다.$$\Theta(\frac{n(n-1)}2 \times log(\frac{n(n-1)}2)) = \Theta(n^2log(n^2)) = \Theta(2n^2log(n)) = \Theta(n^2log(n))$$
- V개의 vertex중 최소 edge 개수는 n-1개이다. 이때의 시간복잡도는 아래와 같다.$$\Theta((n-1)log(n-1)) = \Theta(nlogn)$$
- Prim Algorithm의 시간복잡도는 아래와 같다.$$\Theta(n^2)$$
- 따라서 edge의 개수가 많을 경우에는 Prim Algorithm이 더 빠르고, edge의 개수가 적을 경우에는 Kruskal Algorithm이 더 빠르다.