<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  
<title>TCP | Rounding Off</title>



<meta property="og:title" content="TCP">



<meta name="author" content="JS970">


<meta property="og:locale" content="en-US">


<meta name="description" content="writing is much easier than remembering">
<meta property="og:description" content="writing is much easier than remembering">



<link rel="canonical" href="https://js970.github.io/tcp/">
<meta property="og:url" content="https://js970.github.io/tcp/">



<meta property="og:site_name" content="Rounding Off" />





  <meta property="og:type" content="article" />
  <meta property="article:published_time" content="2022-11-22T00:00:00+00:00">







  <meta name="twitter:card" content="summary">



  <meta property="twitter:title" content="TCP">








<script type="application/ld+json">
{
  "author": {
    "@type":"Person",
	  "name":"JS970",
  },
  "description": "writing is much easier than remembering",
  "url": "https://js970.github.io/tcp/",
  "@context":"https://schema.org",
  "@type": "BlogPosting",
  "headline": "TCP"
  
    
    
      "datePublished":"2022-11-22T00:00:00+00:00",
    
    "mainEntityOfPage":{
      "@type":"WebPage",
      "@id":"https://js970.github.io/tcp/"
    },
  
}
</script>

  <link rel="stylesheet" href="https://js970.github.io/main.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700">

  <link rel="icon" type="image/png" sizes="32x32" href="https://js970.github.io/assets/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://js970.github.io/assets/favicon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="https://js970.github.io/assets/apple-touch-icon.png">

  
    <link type="application/atom+xml" rel="alternate" href="https://js970.github.io/atom.xml" title="Rounding Off" />
  

  

  
  
</head>

<body>
  
  <nav class="nav">
    <div class="nav-container">
      <a href="https://js970.github.io/">
        <h2 class="nav-title">Rounding Off</h2>
      </a>
      <ul>
        
          
            <li><a href="https://js970.github.io">Posts</a></li>
          
            <li><a href="https://js970.github.io/tags">Tags</a></li>
          
            <li><a href="https://js970.github.io/about">About</a></li>
          
        
      </ul>
    </div>
  </nav>
  

  <main>
    
  <div class="post">
  	<div class="post-info">
  		<span>Written by</span> JS970<br>
  		
  		<span>on&nbsp;</span><time datetime="2022-11-22">November 22, 2022</time>
  	</div>
  	<h1 class="post-title">TCP</h1>
  	<div class="post-line"></div>
  	<h1 id="transmission-layer">Transmission Layer</h1>
<ul>
<li>기본적으로 네트워크 스택의 각 계층은 Independent이다.</li>
<li>IP 와 TCP는 상호간의 “talk”이 존재한다. ⇒ Cross-Layer</li>
<li>지연 보장, 대역폭 보장은 지원하지 않는다.</li>
</ul>
<h2 id="tcp-transmission-control-protocol">TCP (Transmission Control Protocol)</h2>
<ul>
<li>Realiable, in-order(순차적인) byte-stream delivery</li>
<li>process to process → 라우터는 TCP를 사용하지 않는다.</li>
<li>Congestion control 지원(sender)</li>
<li>Flow control 지원(receiver)</li>
</ul>
<h2 id="udp-user-datagram-protocol">UDP (User Datagram Protocol)</h2>
<ul>
<li>사용자 데이터그램 프로토콜 - 데이터를 데이터그램 단위로 처리함
<ul>
<li>데이터그램 : 독립적인 관계를 지니는 패킷</li>
<li>각각의 패킷은 서로 다른 라우팅 경로를 통해 전송됨</li>
</ul>
</li>
<li>Unreliable, unordered delivery</li>
<li>IP의 “best effort”의 확장</li>
</ul>
<p><img src="/image/TCP/Untitled.png" alt="Untitled" /></p>
<ul>
<li>UDP segment의 Length부분은 헤더의 길이를 포함한다.</li>
<li>UDP의 특징
<ul>
<li>no connection establishment (connection establishment는 지연을 유발함)</li>
<li>simple : no connection state at sender, receiver</li>
<li>헤더 크기가 작다</li>
<li>congestion control이 없다 : 원하는 만큼 빠르게 동작할 수 있다.</li>
<li>UDP checksum ⇒ IP에서의 checksum과 동일하게 계산된다.
<ul>
<li>16비트 단위의 sum, carry발생 시 + 1</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="tcp">TCP</h1>
<ul>
<li>Connection 의 설정/종료
<ul>
<li>3-way handshaking을 통해 Connection Establishment가 이뤄진다.</li>
<li>4-way handshaking을 통해 Connection Termination이 이뤄진다.</li>
</ul>
</li>
<li>Stop and Wait</li>
<li>Sliding Window
<ul>
<li>smart reciever</li>
<li>dumb sender</li>
</ul>
</li>
<li>Flow Control
<ul>
<li>Flow control은 sender가 receiver의 허용되는 버퍼 용량 이상으로 overrunning하는 것을 방지한다.</li>
<li>end-to-end issue이다.</li>
</ul>
</li>
<li>Adaptive Timeout
<ul>
<li>서버와 클라이언트 사이의 데이터 교환이 없을 경우 일반적으로 2시간의 Timeout을 가지고 disconnect된다.(설정가능)</li>
</ul>
</li>
<li>Congestion Control
<ul>
<li>Congestion Control(혼잡 방지)은 네트워크를 통해 너무 많은 데이터가 전송되어 스위치 또는 링크에 과부하가 걸리는 것을 방지한다.</li>
<li>IPv6의 경우 ECN(Explicit Congestion Notification)이 존재한다.</li>
<li>이를 통해 라우터가 congestion의 존재를 알 수 있다.
<ul>
<li>packet arrival rate &gt; service rate인 경우</li>
</ul>
</li>
<li>IPv4에서는 RTT(Round Trip Time)를 통해 “추측” 할 뿐이다.</li>
</ul>
</li>
<li>TCP에는 7개의 타이머가 있다. 이를 이용해서 reliable connection을 보장한다.
<ul>
<li>retransmission timer, persistant timer, keep alive timer … (총 7개)</li>
</ul>
</li>
</ul>
<h2 id="transport-services-and-protocols">Transport services and protocols</h2>
<ul>
<li>서로 다른 호스트에서 실행되는 어플리케이션 프로세스 간의 논리적 통신 제공</li>
<li>Transport system은 end systems 간에 실행된다.</li>
<li>송신 측 : 어플리케이션 계층의 앱 메시지를 세그먼트 단위로 분할하고 네트워크 계층으로 전달한다.</li>
<li>수신 측 : 세그먼트를 메시지로 재구성한다. 이를 어플리케이션 계층으로 전달한다.</li>
<li>어플리케이션 계층에서는 하나 이상의 전송 프로토콜을 사용 가능한다.
<ul>
<li>Internet : TCP &amp; UDP</li>
</ul>
</li>
</ul>
<h2 id="transport-layer-vs-network-layer">Transport Layer vs Network Layer</h2>
<h3 id="transport-layer">Transport Layer</h3>
<ul>
<li>프로세스 간의 통신</li>
<li>네트워크 계층에 의존하며, 네트워크 계층을 강화한다(?).</li>
</ul>
<h3 id="network-layer">Network Layer</h3>
<ul>
<li>host간의 통신</li>
</ul>
<h2 id="tcp-segment-structure">TCP segment Structure</h2>
<ul>
<li>Wireshark TCP 과제 참고할 것</li>
</ul>
<p><img src="/image/TCP/Untitled%201.png" alt="Untitled" /></p>
<h3 id="src-dest-port">src, dest port</h3>
<ul>
<li>송신지 및 수신지 포트 번호</li>
</ul>
<h3 id="sequence-number-acknowledgement-number">sequence number, acknowledgement number</h3>
<ul>
<li>세그먼트 단위가 아닌 바이트 단위로 카운팅한다.</li>
<li>sequence number는 TCP segment의 연속된 데이터 번호이다. 전송되는 세그먼트의 가장 앞에 있는 숫자를 표기한다.
<ul>
<li>패킷이 1000 ~ 1150까지의 TCP 세그먼트 데이터를 전송한다면 sequence number는 1000이다. 다음 sequence number는 1151이다.</li>
<li>acknowledgement number(ACK #)는 상대방으로부터 받아야하는 다음 TCP 세그먼트의 데이터 번호</li>
<li>acknowledgement number는 $0$ ~ $2^{32}-1$의 값을 가질 수 있다. 이때 대역폭에 따라 ACK의 warp around time을 구할 수 있다.
<ul>
<li>T1(1.5Mbps의 대역폭)의 경우 $2^{32}-1 / 1.5*2^{6} = 6.4hours$의 ACK warp aroound time을 가진다.</li>
<li>STS-24(1.2Gbps의 대역폭)의 경우 $2^{32}-1 / 1.2*2^{9} = 28second$의 ACK warp around time을 가진다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="head-length-data-offset-not-used-reserved">head length(data offset), not used(reserved)</h3>
<ul>
<li>TCP 헤더의 길이를 나타낸다.</li>
<li>최소 크기는 5word(20byte)이고, 최대 크기는 15word(60byte)이다.
<ul>
<li>1word = 4byte</li>
</ul>
</li>
<li>not used부분은 future use를 위해 남겨두는 부분이며 0으로 설정된다.</li>
</ul>
<h3 id="u-urg">U(URG)</h3>
<ul>
<li>Urgent point field의 significant를 가리킨다.</li>
</ul>
<h3 id="a-ack">A(ACK)</h3>
<ul>
<li>ACK field의 significant를 가리킨다. 클라이언트에서 보낸 초기 SYN패킷 이후의 모든 패킷에는 이 플래그가 set 된다.</li>
</ul>
<h3 id="p-psh">P(PSH)</h3>
<ul>
<li>Push function이다. buffered data를 receiving application으로 push 할지를 결정한다.
<ul>
<li>버퍼에 들어오자마자 push…?</li>
</ul>
</li>
</ul>
<h3 id="r-rst">R(RST)</h3>
<ul>
<li>Reset the connection</li>
</ul>
<h3 id="s-syn">S(SYN)</h3>
<ul>
<li>sequence number를 동기화한다. 서버 및 클라이언트에서 송신한 첫 번째 패킷에서만 이 flag를 사용한다.</li>
</ul>
<h3 id="f-fin">F(FIN)</h3>
<ul>
<li>sender의 마지막 패킷을 가리킨다.</li>
</ul>
<h2 id="tcp-establishment-termination-and-retransmission-scenarios">TCP Establishment, Termination and retransmission scenarios</h2>
<h3 id="tcp-establishment">TCP Establishment</h3>
<p><img src="/image/TCP/Untitled%202.png" alt="Untitled" /></p>
<ul>
<li>TCP Establishment는 3-way handshaing으로 이뤄진다.</li>
<li>Sequence Number는 random number로 설정된다(항상 0부터 시작되는 것이 아님)</li>
<li>Sequence Number는 byte stream의 번호이다.</li>
<li>Acknowledge Number는 반대쪽에서 전송행야 할 다음 byte를 말한다.</li>
<li>순서가 뒤죽박죽인 segment를 정렬하는 것 ⇒ TCP구현의 문제이다.</li>
</ul>
<h3 id="tcp-termination">TCP Termination</h3>
<p><img src="/image/TCP/Untitled%203.png" alt="Untitled" /></p>
<ul>
<li>Client 와 Server모두 Terminate를 시작할 수 있다.</li>
<li>Client가 Terminate를 시작한다고 했을 때의 시나리오는 아래와 같다.
<ul>
<li>Client가 TCP FIN 패킷을 전송한다.</li>
<li>Server가 TCP FIN 패킷에 대한 ACK를 전송한다.</li>
<li>Client는 이후 Server로부터의 FIN 패킷 수신을 대기한다.</li>
<li>Server가 전송한 FIN 패킷을 수신하면 Client는 Server로 ACK패킷을 전송한다.</li>
</ul>
</li>
<li>위와 같은 4-way handshaking으로 TCP Terminate가 이뤄진다.</li>
</ul>
<h3 id="tcp-retransmission-scenarios">TCP retransmission scenarios</h3>
<ul>
<li>Host A에서 전송한 패킷에 대한 Host B의 ACK가 loss된 경우이다.</li>
</ul>
<p><img src="/image/TCP/Untitled%204.png" alt="Untitled" /></p>
<ul>
<li>Timeout 이내에 ACK를 수신하지 못했을 경우, 아래 그림과 같이 Host A는 ACK를 받지 못한 패킷을 Host B로 재전송한다.</li>
</ul>
<p><img src="/image/TCP/Untitled%205.png" alt="Untitled" /></p>
<ul>
<li>Host B로부터의 ACK가 Timeout이후에 Host A로 도달하는 경우이다.</li>
<li>Host A는 Timeout내에 ACK를 수신하지 못했으므로 Segment #92부터 시작하는 패킷을 재전송한다.</li>
<li>하지만 Host B는 이미 #119까지의 데이터를 모두 수신한 상태이기 때문에 Host A에게 Segment #120을 요구하는 ACK를 전송한다.</li>
<li>아래 경우는 Timeout 이내에서 ACK 100이 loss되었으나 ACK 120은 정상적으로 전송된 경우이다.</li>
</ul>
<p><img src="/image/TCP/Untitled%206.png" alt="Untitled" /></p>
<ul>
<li>Cumulative ACK scenario에 의해 ACK 100이 loss되어도 ACK 120이 Timeout내에 전송되면 Don’t care이다.</li>
<li>이를 통해 Dumb Sender &amp; Smart Receiver를 확인할 수 있다.
<ul>
<li>receiver측에서 패킷이 연속적으로 존재하는 것을 확인했으므로 ACK 120을 전송</li>
<li>sender는 ACK의 요구대로 전송</li>
</ul>
</li>
</ul>
<h2 id="tcp-state-diagram">TCP State Diagram</h2>
<p>출처 : <a href="https://ssup2.github.io/theory_analysis/TCP_Connection_State/">https://ssup2.github.io/theory_analysis/TCP_Connection_State/</a>
<img src="https://ssup2.github.io/images/theory_analysis/TCP_Connection_State/TCP_Connection_State_Diagram.PNG" alt="TCP State Diagram" /></p>
<h3 id="tcp-client-lifecycle">TCP Client lifecycle</h3>
<p><img src="/image/TCP/Untitled%208.png" alt="Untitled" /></p>
<h3 id="tcp-server-lifecycle">TCP Server lifecycle</h3>
<p><img src="/image/TCP/Untitled%209.png" alt="Untitled" /></p>
<ul>
<li>LISTEN state에서 passive participant(server)의 local process가 send operation을 호출하면 SYN_SENT상태로 전이하기도 한다. 이는 마치 active connection establishment처럼 보인다.</li>
</ul>
<p><img src="/image/TCP/Untitled%2010.png" alt="Untitled" /></p>
<h3 id="tcp-connection-terminating">TCP  connection terminating</h3>
<ul>
<li>ESTABLISHED 상태에서 CLOSED상태로 전이하는 세 가지 조합이 존재한다.</li>
<li>Active Closer : 먼저 close() 하는 Host</li>
<li>Passive Closer : FIN을 수신하고 이후에 close하는 Host</li>
</ul>
<ol>
<li>Active Closer
<ul>
<li>ESTABLISHED → FIN_WAIT→ FIN_WAIT_2 → TIME_WAIT → CLOSED
<ol>
<li>Active Closer가 FIN을 전송하고 FIN_WAIT_1로 전이한다.</li>
<li>Passive Closer로부터 ACK를 수신하고 FIN_WAIT_2로 전이한다.</li>
<li>Passive Closer로부터 FIN을 수신하고 TIME_WAIT로 전이한다.</li>
<li>2MSL(Maximum Segment Lifetime)만큼 TIME_WAIT가 유지된 후 CLOSED로 전이한다.</li>
</ol>
</li>
</ul>
</li>
<li>Passive Closer
<ul>
<li>ESTABLISHED → CLOSE_WAIT → LAST_ACK → CLOSED
<ol>
<li>CLOSE_WAIT 상태는 Passive Closer가 Active Closer로부터 FIN을 수신하고 전이하는 상태이다.</li>
<li>Passive Closer가 close() System Call을 호출하거나 Passive Closer의 Process가 종료되면 Passive Closer는 FIN을 전송하고 LAST_ACK상태가 된다.</li>
<li>CLOSE_WAIT상태의 Passive Closer가 FIN을 전송한 후 이에 대한 ACK를 전송받기 전까지의 상태이다.</li>
<li>ACK를 수신하고 CLOSED로 전이한다.</li>
</ol>
</li>
</ul>
</li>
<li>동시에 close하는 경우(둘다 Active Closer)
<ul>
<li>ESTABLISHED → FIN_WAIT_1 → CLOSING → TIME_WAIT → CLOSED
<ol>
<li>simultaneous closes가 발생하여 FIN_WAIT_1상태의 두 Active Closer가 FIN을 수신한다.</li>
<li>이 경우 두 Active Closer들은 FIN_WAIT_1에서 CLOSING 상태로 전이한다.</li>
<li>다른 Host로부터 ACK를 전송받고 TIME_WAIT로 전이한다.</li>
<li>TIME_WAIT에서 2MSL만큼 대기한 후 CLOSED로 전이한다.</li>
</ol>
</li>
</ul>
</li>
</ol>
<h3 id="why-time-wait">Why TIME_WAIT?</h3>
<ul>
<li>TIME_WAIT 상태에서는 2 Maximum Segment  Lifetime만큼 TIME_WAIT가 유지된다.</li>
<li>Maximum Segment Lifetime은 개념적으로 end point간의 round trip에 걸리는 시간이다.</li>
<li>1MSL은 보통 1분 ~ 4분 정도이다.</li>
<li>TCP의 전이중 연결(full-duplex connection)이 reliable하게 종료되도록 하기 위해 TIME_WAIT가 필요하다.</li>
<li>네트워크 상에서 종료된 Connection관련 Segment들이 완전히 제거 될때까지 대기하여 이후에 생성되는 새로운 Connection에 영향을 미치지 않도록 하기 위해 필요하다.</li>
</ul>
<p><img src="/image/TCP/Untitled%2011.png" alt="Untitled" /></p>
<h2 id="tcp-error-control">TCP Error Control</h2>
<h3 id="stop-and-wait-arq">Stop-and-Wait ARQ</h3>
<ul>
<li>
<p>이 방법에서는 전송 데이터의 복사본을 유지하고 있다가 타이머가 만료되면 재전송한다.</p>
</li>
<li>
<p>Wi-Fi등에서 사용된다.</p>
</li>
<li>
<p>Stop-and-Wait에서는 frame의 numbering을 위해 sequence number를 사용한다.</p>
</li>
<li>
<p>sequence number는 modulo-2공간에 기반한다.</p>
<p><img src="/image/TCP/Untitled%2012.png" alt="Untitled" /></p>
<p><img src="/image/TCP/Untitled%2013.png" alt="Untitled" /></p>
</li>
<li>
<p>Stop-and-Wait에서는 다음 frame number의 modulo-2연산한 값을 acknowledgement number로 사용한다.</p>
</li>
<li>
<p>Stop-and-Wait의 Flow Diagram은 아래와 같다.</p>
<p><img src="/image/TCP/Untitled%2014.png" alt="Untitled" /></p>
</li>
<li>
<p>Bandwidth-delay product</p>
<ul>
<li>Bandwidth * Delay = round trip당 최대 전송 가능한 크기</li>
<li>1Mbps의 대역폭을 가지는 통신에서 round trip delay 가 20ms 라고 하자
<ul>
<li>$(1*10^6) * (20 * 10^{-3}) = 20000$</li>
<li>즉, 20ms안에 최대 20000bit의 전송이 가능하다.</li>
<li>이때 frame의 크기가 1000bit라고 하면 $utilization = 1000 / 20000 = 5 %$ 이다.</li>
<li>이처럼 Stop-and-Wait방식에서는 대역폭이 크거나 frame의 크기가 작다면 대역폭을 낭비가 심하다.</li>
<li>주로 Wi-Fi등의 noise가 심한 통신 방법에서 사용한다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="go-back-n-arq">Go - Back - N ARQ</h3>
<p><img src="/image/TCP/Untitled%2015.png" alt="Untitled" /></p>
<ul>
<li>
<p>Segment #5, Segment #6이 수신되었지만 #3, #4가 제대로 수신되지 않았다.</p>
</li>
<li>
<p>reveiver에서는 ACK 3을 전송하였으나 #5, #6을 수신한 꼴이 된다. → ACK 3을 각각의 Segment에 대해 전송할 것이다.</p>
</li>
<li>
<p>위의 그림에서는 재전송된 ACK 3이 도착하기 전에 Host A의 Timeout이 경과하여 ACK를 수신하지 못한 Host A가 수신하지 못한 첫 번째 ACK인 Segment #2(ACK 3이 수신되어야 했다)로 되돌아가 Segment를 재전송한다. (Go - Back - N)</p>
</li>
<li>
<p>Go-Back-N방법에서는 sequence number는 modulo $2^m$공간 안에 존재한다.</p>
</li>
<li>
<p>Send window size는 최대 $2^m-1$의 크기를 가진다.</p>
<ul>
<li>$2^m$의 크기를 가지게 되면 모든 ACK가 loss되었을 때 다음번 수신된 Frame이 정상적으로 인식되는 문제가 있다.</li>
<li>위의 경우 경우 실제로 전송된 정보는 sender window가 sliding되지 않았으므로 sender window에서 이전에 전송한 Frame이 재전송된다.</li>
</ul>
</li>
<li>
<p>Go-Back-N은 이미 성공적으로 전송된 프레임이 있다고 하더라도 이전에 와야 할 프레임이 제대로 전송되지 않았다면 전송에 실패한 프레임부터 차례대로 재전송해야 한다. ⇒optimal 하지 않음</p>
<p><img src="/image/TCP/Untitled%2016.png" alt="Untitled" /></p>
</li>
<li>
<p>Stop-and-Wait는 Go-Back-N에서 send window의 크기가1인 특수한 경우로 생각할 수 있다.</p>
</li>
</ul>
<h3 id="selective-repeat-arq">Selective Repeat ARQ</h3>
<ul>
<li>sender 및 receiver의 window size는 $2^{(sequence\ number\ field\ in \ bits)-1}$이하의 크기를 가질 수 있다.</li>
<li>sender측에서는 Go-Back-N과 동일하게 sender window의 모든 값들을 ACK없이 전송 가능하다.</li>
<li>receiver에서는 수신한 Frame에 대해서 검사하고 ACK를 전송한다, 전달받은 Frame에 대해서 receiver window를 slide한다.</li>
<li>하지만 receiver window에서 전송받지 못한 Frame이 있다면 이에 대해 NAK를 전송한다. 이후 전송받은 Frame에 대해서는 버퍼에서 유지하고 있는다.</li>
<li>NAK에 대해 정상적으로 재전송이 이루어졌다면 receiver window를 slide한다.</li>
<li>아래 그림은 sender window 및 receiver window의 크기가 4인 경우에 대한 selective reaeat scenario이다.
<ul>
<li>왼쪽 그림은 ACK loss가 발생했을 때의 동작이고, 오른쪽 그림은 Frame loss가 발생했을 때의 동작이다.</li>
</ul>
</li>
</ul>
<p><img src="/image/TCP/Untitled%2017.png" alt="Untitled" /></p>
<h2 id="tcp-flow-control">TCP Flow Control</h2>
<ul>
<li>
<p>Receiver에 의해 flow control 이 이뤄진다.</p>
</li>
<li>
<p>TCP header의 AdvertisedWindow를 이용하여 receiver가 사용 가능한 buffer공간을 sender에게 전송한다.</p>
</li>
<li>
<p>Receicver 버퍼의 오버플로우를 막기 위해 아래를 만족해야 한다.</p>
<p>LastByteRcvd-LastByteRead ≤ Sizeof(MaxRcvBuffer)</p>
<p><img src="/image/TCP/Untitled%2018.png" alt="Untitled" /></p>
</li>
<li>
<p>정확한 AdvertisedWindow의 값의 계산은 아래와 같다.</p>
<ul>
<li>AdvertisedWindow = MaxRcvBuffer - {(NextByteExpected - 1) - LastByteRead - {the amount of out-of-order data received since the NextByteExpected Sequence Number)}</li>
</ul>
</li>
<li>
<p>Receiver process에서 무거운 작업을 처리하는 등의 이유로 Read가 지연되면 자연히 AdvertisedWindow의 크기는 줄어들게 되며, 결국은 0으로 수렴할 것이다.</p>
<p>⇒ Slow Receiving process는 결국 빠른 sending process를 멈추게 될 것이다.</p>
</li>
</ul>
<h1 id="reference">reference</h1>
<p><a href="https://mangkyu.tistory.com/15">[TCP/UDP] TCP와 UDP의 특징과 차이</a></p>
<p><a href="https://ssup2.github.io/theory_analysis/TCP_Connection_State/">TCP Connection State</a></p>
<p><a href="https://www.ibm.com/docs/en/zos/2.1.0?topic=SSLTBW_2.1.0/com.ibm.zos.v2r1.halu101/constatus.html">TCP connection status</a></p>
<p><a href="https://vicente-blog.com/blog/66/">[네트워크프로토콜] 흐름제어, 에러제어</a></p>
<p><a href="https://mslilsunshine.tistory.com/102">Window Size란?</a></p>

  </div>

	

  <div class="pagination">
  	
		<a href="#" class="top">Top</a>
		
  </div>

  </main>

  
  <footer>
    <span>&copy; 2022 JS970. Made with <a href="https://www.getzola.org">Zola</a> using the <a
          href="https://github.com/aaranxu/tale-zola">Tale-Zola</a> theme.</span>
  </footer>
  
</body>
</html>
