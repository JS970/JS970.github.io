<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  
<title>Prolog | Rounding Off</title>



<meta property="og:title" content="Prolog">



<meta name="author" content="JS970">


<meta property="og:locale" content="en-US">


<meta name="description" content="writing is much easier than remembering">
<meta property="og:description" content="writing is much easier than remembering">



<link rel="canonical" href="https://js970.github.io/prolog/">
<meta property="og:url" content="https://js970.github.io/prolog/">



<meta property="og:site_name" content="Rounding Off" />





  <meta property="og:type" content="article" />
  <meta property="article:published_time" content="2023-05-04T00:00:00+00:00">







  <meta name="twitter:card" content="summary">



  <meta property="twitter:title" content="Prolog">








<script type="application/ld+json">
{
  "author": {
    "@type":"Person",
	  "name":"JS970",
  },
  "description": "writing is much easier than remembering",
  "url": "https://js970.github.io/prolog/",
  "@context":"https://schema.org",
  "@type": "BlogPosting",
  "headline": "Prolog"
  
    
    
      "datePublished":"2023-05-04T00:00:00+00:00",
    
    "mainEntityOfPage":{
      "@type":"WebPage",
      "@id":"https://js970.github.io/prolog/"
    },
  
}
</script>

  <link rel="stylesheet" href="https://js970.github.io/main.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700">

  <link rel="icon" type="image/png" sizes="32x32" href="https://js970.github.io/assets/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://js970.github.io/assets/favicon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="https://js970.github.io/assets/apple-touch-icon.png">

  
    <link type="application/atom+xml" rel="alternate" href="https://js970.github.io/atom.xml" title="Rounding Off" />
  

  

  
  
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
	integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
	<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
	integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
	<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
	integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
	onload="renderMathInElement(document.body);"></script>

</head>

<body>
  
  <nav class="nav">
    <div class="nav-container">
      <a href="https://js970.github.io/">
        <h2 class="nav-title">Rounding Off</h2>
      </a>
      <ul>
        
          
            <li><a href="https://js970.github.io">Posts</a></li>
          
            <li><a href="https://js970.github.io/tags">Tags</a></li>
          
            <li><a href="https://js970.github.io/about">About</a></li>
          
        
      </ul>
    </div>
  </nav>
  

  <main>
    
  <div class="post">
  	<div class="post-info">
  		<span>Written by</span> JS970<br>
  		
  		<span>on&nbsp;</span><time datetime="2023-05-04">May  4, 2023</time>
  	</div>
  	<h1 class="post-title">Prolog</h1>
  	<div class="post-line"></div>
  	<h2 id="prolog-intro">Prolog Intro</h2>
<hr />
<h3 id="prolog-history">Prolog History</h3>
<ul>
<li>1972년에 Alain colmerauer와 Philippe Roussel이 만들었다.</li>
<li>1979년에 Kowalski의 논문 Algorithm = Logic + Control에서 소개된 이후 널리 알려졌다.</li>
<li>일본 정부에서 5세대 프로젝트의 기본 언어로 채택되는 등 나름 영향력이 있었다.</li>
</ul>
<h3 id="prolog-resources">Prolog Resources</h3>
<ul>
<li>Prolog Env
<ul>
<li><a href="http://www.swi-prolog.org/">SWI Prolog</a></li>
<li><a href="http://www.visual-prolog.com/">Visual Prolog</a></li>
<li><a href="http://www.dobrev.com/">Strawberry Prolog</a></li>
</ul>
</li>
<li>Prolog Docs
<ul>
<li><a href="https://www.cpp.edu/~jrfisher/www/prolog_tutorial/contents.html">J.R. Fisher, Prolog Tutorial</a></li>
<li><a href="https://www.iso.org/standard/73194.html">Prolog part1 - General core</a></li>
<li><a href="https://pauillac.inria.fr/~deransar/prolog/docs.html">J.P.E. Hudgson, Prolog : The ISO Standard Documents, 1999</a></li>
</ul>
</li>
<li>Prolog Books
<ul>
<li><a href="https://www.pearson.com/uk/educators/higher-education-educators/program/Bratko-Prolog-Programming-for-Artificial-Intelligence-4th-Edition">Ivan Bratko, Prolog Programming for Artificial Intelligence, 4th Ed., AddisonWesley, 2012</a></li>
<li><a href="https://www.learnprolognow.org/">Patrick Blackburn, Johan Bos and Kristina Striegnitz, Learn Proglog Now!, College Publication, 2006</a></li>
<li><a href="https://www.amzi.com/ExpertSystemsInProlog/index.htm">Dennis Merritt, Building Expert System in Prolog, Springer-Verlag, 1989</a></li>
</ul>
</li>
</ul>
<h3 id="ssucajjeo-peuroggeraeonco-heoeo-vs-sseoheojjeo-peuroggeraeonco-heoeo">순차적 프로그래밍 언어 vs 선언적 프로그래밍 언어</h3>
<ul>
<li>순차적 프로그래밍 언어(Procedural Language)
<ul>
<li>BASIC, FORTRAN, C++, Pascal, Java, ...</li>
<li><code>computational step</code>을 일일히 명시해야 한다.</li>
<li><code>computational step</code>이란 <code>instruction</code>, <code>statement</code>, <code>procedure</code>을 통한 계산 과정이다.</li>
<li><code>어떻게(How)</code>문제를 풀어야 하는지 기술한다.</li>
</ul>
</li>
<li>선언적 프로그래밍 언어(Declarative Language)
<ul>
<li>LISP, Prolog, ML, ...</li>
<li><code>computational rules</code>를 기술한다.</li>
<li><code>fact</code>는 <code>computational rules</code>의 한 종류이다.</li>
<li><code>무엇(What)</code>을 풀어야 하는지 기술한다.</li>
</ul>
</li>
<li>사실 순차적 프로그래밍 언어와 선언적 프로그래밍 언어에서 문제의 기술에 관한 부분은 현실에서 항상 명확히 구별되지는 않는다.
<ul>
<li>순차적 프로그래밍 언어에서 타입 선언에 관한 부분은 <code>What</code>으로 생각할 수 있다.</li>
<li>Prolog의 cut은 <code>How</code>에 대한 기술로 생각할 수 있다.</li>
</ul>
</li>
</ul>
<h3 id="computational-model-of-prolog">Computational Model of Prolog</h3>
<ul>
<li>1차 술어 계산(1st-order predicate calculus)을 기반으로 한다.</li>
<li><code>Rule</code>은 <code>Horn clause</code>를 이용하여 표기한다.(CNF, Conjunctive Normal Form)<pre data-lang="Prolog" style="background-color:#2b303b;color:#c0c5ce;" class="language-Prolog "><code class="language-Prolog" data-lang="Prolog"><span>interesting(L) :- lectureByWoo(L), language(L).
</span></code></pre>
</li>
<li><code>Fact</code>는 아무 조건 없이 상상 성립하는 <code>Rule</code>이다.<pre data-lang="Prolog" style="background-color:#2b303b;color:#c0c5ce;" class="language-Prolog "><code class="language-Prolog" data-lang="Prolog"><span>fact.
</span></code></pre>
</li>
<li><code>Goal</code>은 사실인지 확인하고 싶은 명제에 대해 질의하는 것을 의미한다. 질의의 결과는 참 또는 거짓이다.<pre data-lang="Prolog" style="background-color:#2b303b;color:#c0c5ce;" class="language-Prolog "><code class="language-Prolog" data-lang="Prolog"><span>?- goal.
</span></code></pre>
</li>
<li>아래는 <code>Rule</code>, <code>Fact</code>를 포함하는 Prolog프로그램의 예시이다.<pre data-lang="Prolog" style="background-color:#2b303b;color:#c0c5ce;" class="language-Prolog "><code class="language-Prolog" data-lang="Prolog"><span>lectureByWoo(prolog).
</span><span>lectureByWoo(scheme).
</span><span>language(prolog).
</span><span>language(scheme).
</span><span>
</span><span>interesting(L) :- lectureByWoo(L), language(L).
</span></code></pre>
</li>
<li>위 프로그램을 실행하여 질의하면 아래와 같다.<pre data-lang="Prolog" style="background-color:#2b303b;color:#c0c5ce;" class="language-Prolog "><code class="language-Prolog" data-lang="Prolog"><span>?- interesting(prolog).
</span><span>true.
</span><span>
</span><span>?- interesting(scheme).
</span><span>true.
</span><span>
</span><span>?- interesting(cpp).
</span><span>false.
</span></code></pre>
</li>
</ul>
<h2 id="swi-prolog-basic">SWI-Prolog Basic</h2>
<hr />
<h3 id="gibbo-sahyonbbeo">기본 사용법</h3>
<ul>
<li>프로그램 소스 편집<pre data-lang="Prolog" style="background-color:#2b303b;color:#c0c5ce;" class="language-Prolog "><code class="language-Prolog" data-lang="Prolog"><span>edit(file(&#39;filename.pl&#39;)).
</span></code></pre>
</li>
<li>프로그램 파일 참조(load). 두 표현은 같은 표현이다.<pre data-lang="Prolog" style="background-color:#2b303b;color:#c0c5ce;" class="language-Prolog "><code class="language-Prolog" data-lang="Prolog"><span>?- consult(filename).
</span><span>
</span><span>?- [filename].
</span></code></pre>
</li>
<li>질의
<ul>
<li>parent에 관한 아래와 같은 <code>rule</code>이 있다.</li>
</ul>
<pre data-lang="Prolog" style="background-color:#2b303b;color:#c0c5ce;" class="language-Prolog "><code class="language-Prolog" data-lang="Prolog"><span>	son(jim, jane).
</span><span>	son(jim, john).
</span><span>
</span><span>	parent(X, Y) :- son(Y, X).
</span></code></pre>
<ul>
<li>아래 질의에서는 parent <code>rule</code>을 만족시키는지를 반환한다.</li>
</ul>
<pre data-lang="Prolog" style="background-color:#2b303b;color:#c0c5ce;" class="language-Prolog "><code class="language-Prolog" data-lang="Prolog"><span>	?- parent(jane, jim).
</span></code></pre>
<ul>
<li>아래 질의에서는 목적을 명시하여 답변을 얻는다.</li>
<li>질의가 true가 되도록 하는 결과를 출력한다.</li>
<li>답변에 만족했다면 질의 이후 &quot;enter&quot;를 입력하면 질의가 종료된다.</li>
<li>다른 답변을 원한다면 질의 이후 &quot;;&quot;를 입력하여 게속 질의할 수 있다.</li>
</ul>
<pre data-lang="Prolog" style="background-color:#2b303b;color:#c0c5ce;" class="language-Prolog "><code class="language-Prolog" data-lang="Prolog"><span>	?- parent(X, jim).
</span></code></pre>
<ul>
<li>답변 출력(jane에서 <code>;</code>를 입력하여 다른 답을 요청했다)</li>
</ul>
<pre data-lang="Prolog" style="background-color:#2b303b;color:#c0c5ce;" class="language-Prolog "><code class="language-Prolog" data-lang="Prolog"><span>	X = jane ;
</span><span>	X = john.
</span></code></pre>
</li>
<li>해석기 종료<pre data-lang="Prolog" style="background-color:#2b303b;color:#c0c5ce;" class="language-Prolog "><code class="language-Prolog" data-lang="Prolog"><span>	?- halt.
</span></code></pre>
</li>
</ul>
<h3 id="prolog-predicate-term">Prolog = predicate + term</h3>
<ul>
<li>Prolog는 <code>computational rules</code>를 <code>Horn clause</code>를 사용하여 정의한다.</li>
<li><code>Horn clause</code>는 <code>predicate</code>(술어) 와 <code>term</code>(항)으로 구성된다.</li>
<li><code>predicate</code>(술어) : 소문자로 시작하며, 상수의 일종으로 생각할 수 있다.</li>
<li><code>term</code>(항): 변수 또는 상수이다.
<ul>
<li>변수 : <code>_</code>또는 대문자로 시작한다.</li>
<li>상수 : 소문자로 시작한다.</li>
</ul>
</li>
<li><code>Clause</code>(절) : <code>predicate</code>의 개별 정의를 <code>clauses</code>라고 한다.
<ul>
<li><code>fact</code>, <code>rule</code>모두 <code>Clause</code>에 포함된다.</li>
<li>아래 문장은 <code>fact</code>로 이루어진 하나의 <code>Clause</code>이다.<pre data-lang="Prolog" style="background-color:#2b303b;color:#c0c5ce;" class="language-Prolog "><code class="language-Prolog" data-lang="Prolog"><span>parent(jane, alen).
</span></code></pre>
<ul>
<li><code>body</code>없이 <code>fact</code>로만 이루어져 있으므로 항상 참이다.</li>
</ul>
</li>
<li>아래 문장은 두 개의 <code>Clause</code>로 이루어진 <code>rule</code>이다.<pre data-lang="Prolog" style="background-color:#2b303b;color:#c0c5ce;" class="language-Prolog "><code class="language-Prolog" data-lang="Prolog"><span>parent(X, Y) :- mother(X, Y).
</span></code></pre>
<ul>
<li>좌항은 <code>head</code>, 우항은 <code>body</code>라고 한다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="arguments">Arguments</h3>
<ul>
<li><code>predicate</code>는 인수를 받을 수 있다.</li>
<li><code>term</code>은 <code>상수</code>, <code>변수</code>, <code>복합형</code> 중 하나의 형태이다.
<ul>
<li><code>상수</code> : 소문자로 시작하는 이름을 가진다.
<ul>
<li>수(number) : 정수 및 부동소수점 수</li>
<li>기호상수(symbolic constants) : 항상 소문자로 시작되어야 하며, 숫자, <code>_</code>기호가 그 뒤로 올 수 있다.</li>
<li>문자열 상수(string constants) : 작은 따음표로 감싼 형태이다. 꼭 대문자를 사용하여 상수명을 지정하고 싶을 경우 사용한다.</li>
</ul>
</li>
<li><code>변수</code> : 대문자 또는 <code>_</code>로 시작하는 이름을 가진다.
<ul>
<li>Prolog에서 <code>변수</code>, <code>상수</code>는 type을 가지지 않는다. 즉 어떠한 값이든 될 수 있다.</li>
<li>Prolog에서 모든 <code>변수</code>는 local variable이다.</li>
<li><code>변수</code>의 값은 같은 절(clause)내에서는 일정하며, 절 외부의 값을 유지하는경우는 없다.</li>
</ul>
</li>
<li><code>복합형</code> : 여러 항을 functional constructor(functor)로 묶은 것이다.
<ul>
<li>data constructor이다.</li>
<li>function으로 구성된다.</li>
<li>list역시 복합형이다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="lists">Lists</h3>
<ul>
<li>리스트는 <code>복합형</code> <code>term</code>이며, 아래의 두 가지 형태 중 하나의 형태를 가진다.
<ul>
<li>빈 리스트</li>
<li>원소가 하나 이상인 리스트</li>
</ul>
</li>
<li>일반 항을 사용할 때 아래의 두 가지 패턴 중 하나를 사용하면 된다.
<ul>
<li>빈 리스트 : <code>[]</code></li>
<li>원소가 하나 이상인 리스트 : <code>[H|T]</code></li>
</ul>
</li>
<li>아래는 리스트 사용 예시이다.<pre data-lang="Prolog" style="background-color:#2b303b;color:#c0c5ce;" class="language-Prolog "><code class="language-Prolog" data-lang="Prolog"><span>sum([], 0).
</span><span>sum([H|T], X) :- sum(T|Y), X is H + Y.
</span><span>
</span><span>?- sum([1, 2, 3, 4], X).
</span><span>X = 10
</span></code></pre>
<ul>
<li>X = 10이 유도되는 과정은 아래와 같다.
<ol>
<li>sum([1, 2, 3, 4], X) = sum([2, 3, 4], Y), X = 1 + Y</li>
<li>sum([2, 3, 4], X) = sum([3, 4], Y), X = 2 + Y</li>
<li>sum([3, 4], X) = sum([4], Y), X = 3 + Y</li>
<li>sum([4], X) = sum([], Y), H = 4 + Y, Y = 0, X = H + Y = 4</li>
<li>by 4, 3's Y is 4, 3's X is 7</li>
<li>by 3, 2's Y is 7, 2's X is 9</li>
<li>by 2, 1's Y is 9, 1's X is 10</li>
<li>by 1~7, sum([1, 2, 3, 4], X). X = 10</li>
</ol>
</li>
<li>참고로 Prolog는 선언적 프로그래밍 언어이므로, 위 프로그램의 1행과 2행의 위치를 바꾸어도 정상적으로 동작한다.</li>
</ul>
</li>
</ul>
<h3 id="unification-ddailhwa">Unification(단일화)</h3>
<ul>
<li>변수가 포함된 두 개의 항을 일치시키는 것을 의미하므로 <code>동형화</code>라고 볼 수도 있다.</li>
<li>두 항의 단일화가 가능하다면 <code>일치(match)</code>한다고 한다.</li>
<li>구조와 인수가 맞아야 사용 가능하므로, 서로 다른 상수, 상수와 변수 간에는 <code>match</code>가 불가능하다.</li>
<li>아래는 단일화의 예시이다.<pre data-lang="Prolog" style="background-color:#2b303b;color:#c0c5ce;" class="language-Prolog "><code class="language-Prolog" data-lang="Prolog"><span>?- loves(john, X) = loves(Y, marry).
</span><span>X = mary, Y = john
</span><span>
</span><span>?- loves(john, X) = loves(mary, X).
</span><span>false.
</span></code></pre>
</li>
</ul>
<h3 id="computation">Computation</h3>
<ul>
<li>Prolog에서는 <code>단일화(unification)</code>중 <code>computation</code>이 일어난다.</li>
<li><code>computation</code> : <code>is/2</code> 술어를 통해 수행된다. </li>
<li>값을 계산하기 위해 술어 <code>is</code>를 사용해야 하는 것에 주의하자, <code>=</code>를 사용할 경우 Prolog는 연산하지 않고 값을 그대로 보여준다.</li>
<li>아래는 리스트 절에서 다룬 sum프로그램의 <code>is</code>를 <code>=</code>로 변경한 코드와 그 실행 결과이다.
<ul>
<li>코드<pre data-lang="Prolog" style="background-color:#2b303b;color:#c0c5ce;" class="language-Prolog "><code class="language-Prolog" data-lang="Prolog"><span>sum([], 0).
</span><span>sum([H|T], S) :- sum(T, S1), S = H + S1.
</span></code></pre>
</li>
<li>실행 결과                                                             <img src="/image/PL/isPredecateTest.png" alt="predecate test" /></li>
</ul>
</li>
</ul>
<h3 id="factorial-in-prolog">Factorial in Prolog</h3>
<ul>
<li>아래 프로그램은 Prolog에서 Factorial을 계산하는 코드이다.<pre data-lang="Prolog" style="background-color:#2b303b;color:#c0c5ce;" class="language-Prolog "><code class="language-Prolog" data-lang="Prolog"><span>fact(0, 1).
</span><span>fact(N, M) :-
</span><span>	N &gt; 0,
</span><span>	N1 is N - 1,
</span><span>	fact(N1, M1),
</span><span>	M is N * M1.
</span></code></pre>
</li>
</ul>
<h2 id="prolog-and-tail-recursion">Prolog and Tail Recursion</h2>
<hr />
<h3 id="tail-recursion">Tail Recursion</h3>
<ul>
<li>아래 코드는 계산 결과를 저장하는 변수(M)의 연산이 이뤄지는 부분에서 재귀 이외의 연산이 있다.<pre data-lang="Prolog" style="background-color:#2b303b;color:#c0c5ce;" class="language-Prolog "><code class="language-Prolog" data-lang="Prolog"><span>fact(0, 1).
</span><span>fact(N, M) :-
</span><span>	N &gt; 0,
</span><span>	N1 is N-1,
</span><span>	fact(N1, M1),
</span><span>	M is N * M1.
</span></code></pre>
<ul>
<li>연산 과정을 자세히 살펴보자. 10!을 연산하기 위해서는 아래와 같이 질의해야 한다.<pre data-lang="Prolog" style="background-color:#2b303b;color:#c0c5ce;" class="language-Prolog "><code class="language-Prolog" data-lang="Prolog"><span>?- fact(1, X).
</span></code></pre>
</li>
<li>이때 X는 질의 결과를 저장하는 변수임과 동시에 계산 과정의 중간 결과를 저장하는 변수이다.</li>
<li>프로그램의 마지막 줄에서 M is N * M1부분이 있는데, M1은 fact(N1, M1).의 호출을 통해 도출된다.</li>
<li>X의 값을 구하기 위한 부분에서 fact의 호출 후 이를 N과 곱하는 연산이 추가로 일어나는 것을 확인할 수 있다.</li>
<li>따라서 위 코드는 Tail Recursion이 아니다.</li>
</ul>
</li>
<li>Tail Recursion조건을 만족하도록 <code>fact/3</code>을 작성하면 아래와 같다.<pre data-lang="Prolog" style="background-color:#2b303b;color:#c0c5ce;" class="language-Prolog "><code class="language-Prolog" data-lang="Prolog"><span>fact(0, M, M).
</span><span>fact(N, Acc, F) :-
</span><span>	N &gt; 0,
</span><span>	N1 is N - 1,
</span><span>	Acc1 is Acc * N,
</span><span>	fact(N1, Acc1, F).
</span></code></pre>
<ul>
<li>질의 결과를 저장하는 변수 F와 계산의 중간 결과를 저장하는 Acc를 따로 설정하여 전달하므로 재귀 과정에서 <code>fact/3</code>의 호출 이외의 연산이 일어나지 않는다.</li>
<li>따라서 위 코드는 Tail Recursion 조건을 만족한다.</li>
</ul>
</li>
</ul>
<h3 id="tail-recursiongwa-hyeossa-ssusse">Tail Recursion과 연산 순서</h3>
<ul>
<li>앞서 연산은 <code>is/2</code>로만 이루어지고 <code>=</code>를 사용할 경우 연산 없이 그대로 출력한다고 했다. 이를 이용해서 연산 순서 및 결합 방향에 대해 알아보자.</li>
<li>아래는 Tail Recursion 조건을 만족하지 않는 sum함수이다.<pre data-lang="Prolog" style="background-color:#2b303b;color:#c0c5ce;" class="language-Prolog "><code class="language-Prolog" data-lang="Prolog"><span>sum([], 0).
</span><span>sum([H|T], S) :- sum([T|S1], S1), S is H + S1.	
</span></code></pre>
<ul>
<li>위 코드의 <code>is</code>를 <code>=</code>로 수정하여 연산 순서를 확인하면 아래와 같다.<img src="/image/PL/isPredecateTest.png" alt="predecate test" /></li>
</ul>
</li>
<li>아래는 같은 프로그램을 Tail Recursion 조건을 만족하도록 하여 구현한 코드이다.<pre data-lang="Prolog" style="background-color:#2b303b;color:#c0c5ce;" class="language-Prolog "><code class="language-Prolog" data-lang="Prolog"><span>sum([], Si, Si).
</span><span>sum([H|T], Acc, So) :-
</span><span>	Acc1 is H + Si,
</span><span>	sum(T, Acc1, So).
</span></code></pre>
<ul>
<li>위 코드의 <code>is</code>를 <code>=</code>로 수정하여 연산 순서를 확인하면 아래와 같다.<img src="/image/PL/tailAssign.png" alt="tailAssign" /></li>
</ul>
</li>
<li>Tail Recursion의 경우 Top-Down으로 연산한다. Tail Recursion이 아닌 Recursion의 경우 Bottom-up으로 연산한다.</li>
</ul>
<h2 id="swi-prolog-debugging">SWI-Prolog Debugging</h2>
<hr />
<h3 id="4-port-model-of-prolog-execution">4 Port Model of prolog Execution</h3>
<p><img src="/image/PL/fourPortModel.png" alt="Four Port Model" /></p>
<ul>
<li>위 그림은 Prolog의 프로그램이 실행되는 상태 전이 모형을 나타낸 것이다.</li>
<li><code>Call</code> : 프로그램이 처음 호출되었을 대 사용되는 포트</li>
<li><code>Exit</code>:  프로그램이 진행되어 실행이 종료될 때 사용되는 포트</li>
<li><code>Fail</code> : 프로그램 실행 중 완전히 실패(failure)한 경우 사용되는 포트</li>
<li><code>Redo</code> : failure한 경우 다른 정답을 찾으려 시도할 때 사용되는 포트</li>
</ul>
<h3 id="enable-debugging">Enable Debugging</h3>
<ul>
<li><code>trace/0</code> : 모든 포트에서 정지하도록 설정</li>
<li><code>nottrace/0</code> : 정지 설정을 끈다.</li>
<li><code>debug/0</code> : 디버깅 모드를 활성화한다.</li>
<li><code>nodebug/0</code> : 디버깅 모드를 종료한다.</li>
</ul>
<h3 id="debugging-example">Debugging Example</h3>
<ul>
<li>아래는 짝수인지 판별하는 결함이 있는 Prolog 코드이다.<pre data-lang="Prolog" style="background-color:#2b303b;color:#c0c5ce;" class="language-Prolog "><code class="language-Prolog" data-lang="Prolog"><span>isEven(2).
</span><span>isEven(X) :-
</span><span>	Y is X - 2,
</span><span>	isEven(Y).
</span></code></pre>
<ul>
<li>위 코드의 입력으로 짝수가 주어졌을 때는 프로그램이 정상적으로 동작한다.<img src="/image/PL/noBugDebugging.png" alt="isEven(4) Nobug" /></li>
<li>하지만 입력으로 홀수가 주어졌을 때 프로그램이 종료되지 않는 문제가 있다.<img src="/image/PL/isEven5Bug.png" alt="isEven(5) Bug" /></li>
</ul>
</li>
<li>버그를 수정하기 위해 <code>fail/0</code>을 사용하여 홀수에 대한 처리를 해 주자.<pre data-lang="Prolog" style="background-color:#2b303b;color:#c0c5ce;" class="language-Prolog "><code class="language-Prolog" data-lang="Prolog"><span>isEven(1) :- fail.
</span><span>isEven(2).
</span><span>isEven(X) :-
</span><span>	Y is X - 2,
</span><span>	isEven(Y).
</span></code></pre>
<ul>
<li>하지만 여전히 종료되지 않고 계속해서 실행되는 문제가 있다.<img src="/image/PL/isEven5BugRedo.png" alt="isEven(5) Bug2" /></li>
<li>이는 <code>fail</code>을 유도하지 않는 다른 정답에 대해 계속해서 탐색하기 때문이다.</li>
</ul>
</li>
<li>프로그램이 되추적을 중단시키도록 <code>cut</code>을 사용하도록 코드를 수정한다.<pre data-lang="Prolog" style="background-color:#2b303b;color:#c0c5ce;" class="language-Prolog "><code class="language-Prolog" data-lang="Prolog"><span>isEven(1) :-
</span><span>	!, fail.
</span><span>isEven(2).
</span><span>isEven(X) :-
</span><span>	Y is X - 2,
</span><span>	isEven(Y).
</span></code></pre>
<ul>
<li><code>cut</code>은 위와 같이 <code>!</code>으로 표기한다.</li>
<li>이제는 프로그램이 정상적으로 홀수에 대해서도 처리하는 것을 확인할 수 있다.<img src="/image/PL/isEven5NoBug.png" alt="isEven(5) No Bug" /></li>
</ul>
</li>
</ul>
<h3 id="n-queen-s-problem-with-prolog">N-Queen's Problem with Prolog</h3>
<ul>
<li>다른 프로그래밍 언어에 비해 매우 간단하게 이 문제를 해결할 수 있다.</li>
<li>아래는 N-Queen's Problem을 해결하는 Prolog코드이다.<pre data-lang="Prolog" style="background-color:#2b303b;color:#c0c5ce;" class="language-Prolog "><code class="language-Prolog" data-lang="Prolog"><span>queens(N, Qs) :-
</span><span>	range(1, N, Ns),
</span><span>	permutation(Ns, Qs),
</span><span>	safe(Qs).
</span><span>
</span><span>safe([]).
</span><span>safe([Q|Qs]) :-
</span><span>	safe(Qs),
</span><span>	not(attack(Q, Qs)).
</span><span>
</span><span>attack(X, Xs) :-
</span><span>	attack(X, 1, Xs).
</span><span>
</span><span>attack(X, N, [Y|_]) :-
</span><span>	X is Y + N; X is Y - N.
</span><span>
</span><span>attack(X, N, [_|Ys]) :-
</span><span>	N1 is N + 1,
</span><span>	attack(X, N1, Ys).
</span><span>
</span><span>range(N, N, [N]).
</span><span>range(M, N, [M|Ns]) :-
</span><span>	M &lt; N,
</span><span>	M1 is M + 1,
</span><span>	range(M1, N, Ns).
</span></code></pre>
</li>
<li>위 프로그램을 이용하여 4-Queen, 6-Queen에 대해 정답을 출력한 결과이다.<img src="/image/PL/nqueensProlog.png" alt="NQueens Prolog" /></li>
</ul>

  </div>

	

  <div class="pagination">
  	
		<a href="#" class="top">Top</a>
		
  </div>

  </main>

  
  <footer>
    <span>&copy; 2022 JS970. Made with <a href="https://www.getzola.org">Zola</a> using the <a
          href="https://github.com/aaranxu/tale-zola">Tale-Zola</a> theme.</span>
  </footer>
  
</body>
</html>
