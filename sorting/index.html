<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  
<title>Sorting | Rounding Off</title>



<meta property="og:title" content="Sorting">



<meta name="author" content="JS970">


<meta property="og:locale" content="en-US">


<meta name="description" content="writing is much easier than remembering">
<meta property="og:description" content="writing is much easier than remembering">



<link rel="canonical" href="https://js970.github.io/sorting/">
<meta property="og:url" content="https://js970.github.io/sorting/">



<meta property="og:site_name" content="Rounding Off" />





  <meta property="og:type" content="article" />
  <meta property="article:published_time" content="2023-06-08T00:00:00+00:00">







  <meta name="twitter:card" content="summary">



  <meta property="twitter:title" content="Sorting">








<script type="application/ld+json">
{
  "author": {
    "@type":"Person",
	  "name":"JS970",
  },
  "description": "writing is much easier than remembering",
  "url": "https://js970.github.io/sorting/",
  "@context":"https://schema.org",
  "@type": "BlogPosting",
  "headline": "Sorting"
  
    
    
      "datePublished":"2023-06-08T00:00:00+00:00",
    
    "mainEntityOfPage":{
      "@type":"WebPage",
      "@id":"https://js970.github.io/sorting/"
    },
  
}
</script>

  <link rel="stylesheet" href="https://js970.github.io/main.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700">

  <link rel="icon" type="image/png" sizes="32x32" href="https://js970.github.io/assets/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://js970.github.io/assets/favicon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="https://js970.github.io/assets/apple-touch-icon.png">

  
    <link type="application/atom+xml" rel="alternate" href="https://js970.github.io/atom.xml" title="Rounding Off" />
  

  

  
  
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
	integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
	<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
	integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
	<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
	integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
	onload="renderMathInElement(document.body);"></script>

</head>

<body>
  
  <nav class="nav">
    <div class="nav-container">
      <a href="https://js970.github.io/">
        <h2 class="nav-title">Rounding Off</h2>
      </a>
      <ul>
        
          
            <li><a href="https://js970.github.io">Posts</a></li>
          
            <li><a href="https://js970.github.io/tags">Tags</a></li>
          
            <li><a href="https://js970.github.io/about">About</a></li>
          
        
      </ul>
    </div>
  </nav>
  

  <main>
    
  <div class="post">
  	<div class="post-info">
  		<span>Written by</span> JS970<br>
  		
  		<span>on&nbsp;</span><time datetime="2023-06-08">June  8, 2023</time>
  	</div>
  	<h1 class="post-title">Sorting</h1>
  	<div class="post-line"></div>
  	<h2 id="sorting">Sorting</h2>
<hr />
<h3 id="sort">Sort</h3>
<ul>
<li><code>record</code>를 <code>key</code>값에 따라 재배치하는 것을 의미한다.</li>
<li>두 개의 <code>key</code>를 비교하여 <code>sort</code>를 수행하는 알고리즘은 아래와 같은 연산을 수행해야 한다.
<ul>
<li>두 <code>key</code>를 비교한다.</li>
<li><code>key</code>값을 복사한다.</li>
</ul>
</li>
</ul>
<h3 id="insertion-sort">Insertion Sort</h3>
<ul>
<li>배열을 <code>sorted</code>와 <code>unsorted</code>의 두 연속된 부분으로 나눈다. </li>
<li>초기값은 <code>sorted</code>는 빈 배열, <code>unsorted</code>는 전체 배열이다.</li>
<li><code>unsorted</code>의 첫 번째 원소를 <code>sorted</code>의 첫 번째 원소와 비교한다.</li>
<li><code>sorted</code>의 원소보다 <code>unsorted</code>의 원소가 작다면 해당 <code>sorted</code>의 왼쪽에 삽입한다.</li>
<li><code>sorted</code>의 원소보다 큰 경우 <code>sorted</code>의 원소보다 작아질 때까지 <code>sorted</code>의 index를 1씩 증가시키며 순회한다.</li>
<li>마지막까지 <code>sorted</code>의 원소보다 큰 경우 <code>sorted</code>의 가장 우측에 삽입한다.</li>
<li>이 과정을 <code>unsorted</code>의 크기가 0이 될 때까지 반복한다.</li>
<li>아래 그림은 i = 6인 상황에서의 삽입 정렬 과정을 나타낸 그림이다.<img src="/image/Algorithm/insertionSort.png" alt="Insertion Sort" /></li>
<li><code>worst case</code>에서 <code>quadratic</code>의 시간복잡도를 가지는 정렬 알고리즘이다.</li>
</ul>
<h3 id="exchange-sort">Exchange Sort</h3>
<ul>
<li>배열의 <code>두 번째 원소</code>부터 배열의 <code>마지막 원소</code>까지 배열의 <code>첫 번째 원소</code>와 비교하여 배열의 첫 번째 원소가 더 클 경우 두 값을 교환하는 정렬 방법이다.</li>
<li>배열의 두 번째 원소부터 시작한 교환 과정이 끝나면 배역의 <code>세 번째 원소</code>부터 배열의 <code>마지막 원소</code>까지 배열의 <code>두 번째 원소</code>와 비교하여 교환하는 과정을 거친다.</li>
<li>이렇게 배열의 마지막 직전 원소까지 교환이 끝나면 정렬 과정이 종료된다.</li>
<li><code>worst case</code>에서 <code>quadratic</code>의 시간복잡도를 가지는 정렬 알고리즘이다.</li>
</ul>
<h3 id="selection-sort">Selection Sort</h3>
<ul>
<li><code>exchange sort</code>방법과 유사하다.</li>
<li>배열의 첫 번째 원소부터 배열의 마지막 원소값까지의 모든 값들과 비교한다.</li>
<li>그 중 가장 작은 값과 배열의 첫 번째 원소의 값을 교환한다.</li>
<li>다시 배열의 두 번째 원소에 대해 같은 과정을 수행한다.</li>
<li>이 과정을 배열의 마지막 원소 이전까지의 원소에 대해 수행한다.</li>
<li><code>worst case</code>에서 <code>quadratic</code>의 시간복잡도를 가지는 정렬 알고리즘이다.</li>
</ul>
<h3 id="keyggab-biggyyi-lower-bound">key값 비교의 lower bound</h3>
<ul>
<li>n개의 서로 다른 <code>key</code>값으로 정렬된 집합이 있다고 하자. 편의를 위해 <code>key</code>값은 정수로 가정하자.</li>
<li>이 집합에서 만들어지는 순열 [k1, k2, k3, ..., kn]에 대해서 <code>inversion</code>은 다음과 같은 조건을 만족한다.$$(k_i, k_j) \ such\ that\ i&lt;j\ and\ k_i &gt; k_j$$</li>
<li>즉, [3, 2, 4, 1, 6, 5]에 대한 <code>inversion</code>은 (3, 2), (3, 1), (2, 1), (6, 5), (4, 1)이다.</li>
<li>이러한 <code>inversion</code>을 찾는 알고리즘은 아래와 같은 <code>worst case</code>의 경우 아래와 같은 비교연산의 횟수가 필요하다.$$\frac{n(n-1)}{2}\ comparisons\ of\ keys$$
<ul>
<li>[n, n-1, n-2, ..., 3, 2, 1] 순서로 정렬된 집합이 있다고 생각하자.</li>
<li>n에 대해서는 n-1번의 비교 연산이 필요하다.</li>
<li>n-1에 대해서는 n-2번의 비교 연산이 필요하다.</li>
<li>이렇게 필요한 비교 연산을 모두 수행하면 위와 같은 비교 횟수가 필요함을 알 수 있다.</li>
</ul>
</li>
<li><code>worst case</code>가 아닌 <code>average case</code>의 경우에도 아래와 같은 비교연산의 횟수가 필요하다.$$\frac{n(n-1)}{4}\ comparisons\ of\ keys$$
<ul>
<li>(s, r)이 서로 다른 <code>key</code>값의 쌍이라고 하자. 전체 집합의 원소가 n개라면 (s, r)쌍을 선택하는 것은 아래와 같다.$$the\ number\ of\ distinct\ pairs\ (i, j) = \frac{n(n-1)}{2}$$</li>
<li><code>key</code>쌍의 조합에 대해 <code>inversion</code>일 경우는 i &gt; j인 경우이다. <code>average case</code>에서 이는 1/2의 경우의 수를 가진다.</li>
<li>따라서 <code>average case</code>에서는 위와 같은 비교연산의 횟수가 필요하다.</li>
</ul>
</li>
</ul>
<h3 id="merge-sort">Merge Sort</h3>
<ul>
<li><code>divide and conquer</code>방식의 정렬 알고리즘이다.</li>
<li>배열을 2부분으로 계속 나눈다.</li>
<li>이렇게 생성된 모든 subarray가 크기가 1인 배열이 되면 <code>merge</code>를 시작한다.</li>
<li><code>merge</code>과정에서 <code>key</code>값이 작은 원소를 좌측에 배치한다.</li>
<li>각 <code>merge</code>과정에서 총 n번의 비교 연산을 필요로 한다.</li>
<li><code>divide</code>및 <code>merge</code>과정은 floor(log n)번 일어난다. 따라서 시간복잡도는 <strong>n * log n</strong>이다.</li>
<li>이를 의사 코드로 나타내면 아래와 같다.<pre data-lang="C" style="background-color:#2b303b;color:#c0c5ce;" class="language-C "><code class="language-C" data-lang="C"><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">mergesort</span><span>(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">n</span><span>, keytype </span><span style="color:#bf616a;">S</span><span>[]) {
</span><span>	</span><span style="color:#b48ead;">if </span><span>(n&gt;</span><span style="color:#d08770;">1</span><span>) {
</span><span>		</span><span style="color:#b48ead;">const int</span><span> h = </span><span style="color:#96b5b4;">floor</span><span>(n/</span><span style="color:#d08770;">2</span><span>), m = n - h;
</span><span>		keytype U[</span><span style="color:#d08770;">1</span><span style="background-color:#bf616a;color:#2b303b;">..</span><span>h], V[</span><span style="color:#d08770;">1</span><span style="background-color:#bf616a;color:#2b303b;">..</span><span>m];
</span><span>		copy S[</span><span style="color:#d08770;">1</span><span>] through S[h] to U[</span><span style="color:#d08770;">1</span><span>] through U[h];
</span><span>		copy S[h+</span><span style="color:#d08770;">1</span><span>] through S[n] to V[</span><span style="color:#d08770;">1</span><span>] through V[m];
</span><span>		</span><span style="color:#bf616a;">mergesort</span><span>(h, U);
</span><span>		</span><span style="color:#bf616a;">mergesort</span><span>(m, v);
</span><span>		</span><span style="color:#bf616a;">merge</span><span>(h, m, U, V, S);
</span><span>	}
</span><span>}
</span></code></pre>
<ul>
<li><code>copy</code>연산의 시간복잡도는 <strong>n * log n</strong>이다.</li>
<li><code>merge sort</code>에서 <code>copy</code>연산의 시간복잡도를 고려하면 총 시간복잡도는 <strong>2n * log n</strong>이 된다.</li>
</ul>
</li>
</ul>
<h3 id="improved-merge-sort">Improved Merge Sort</h3>
<ul>
<li>아래와 같이 <code>linked list</code>자료 구조를 사용하여 <code>merge</code>과정을 수행한다고 생각해 보자.<img src="/image/Algorithm/llmerge.png" alt="Linked List Merge Sort" /></li>
<li>레코드가 정렬된 상태를 유지할 필요가 없다면 assignment 연산이 필요 없다.</li>
<li>레코드가 정렬된 상태를 유지해야 한다면 linear의 시간복잡도를 가진다.</li>
</ul>

  </div>

	

  <div class="pagination">
  	
		<a href="#" class="top">Top</a>
		
  </div>

  </main>

  
  <footer>
    <span>&copy; 2022 JS970. Made with <a href="https://www.getzola.org">Zola</a> using the <a
          href="https://github.com/aaranxu/tale-zola">Tale-Zola</a> theme.</span>
  </footer>
  
</body>
</html>
