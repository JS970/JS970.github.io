<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  
<title>운영체제 2023-04-05 수업정리 | Rounding Off</title>



<meta property="og:title" content="운영체제 2023-04-05 수업정리">



<meta name="author" content="JS970">


<meta property="og:locale" content="en-US">


<meta name="description" content="writing is much easier than remembering">
<meta property="og:description" content="writing is much easier than remembering">



<link rel="canonical" href="https://js970.github.io/unhyeonceje-4-5-suheojjeonri/">
<meta property="og:url" content="https://js970.github.io/unhyeonceje-4-5-suheojjeonri/">



<meta property="og:site_name" content="Rounding Off" />





  <meta property="og:type" content="article" />
  <meta property="article:published_time" content="2023-04-09T00:00:00+00:00">







  <meta name="twitter:card" content="summary">



  <meta property="twitter:title" content="운영체제 2023-04-05 수업정리">








<script type="application/ld+json">
{
  "author": {
    "@type":"Person",
	  "name":"JS970",
  },
  "description": "writing is much easier than remembering",
  "url": "https://js970.github.io/unhyeonceje-4-5-suheojjeonri/",
  "@context":"https://schema.org",
  "@type": "BlogPosting",
  "headline": "운영체제 2023-04-05 수업정리"
  
    
    
      "datePublished":"2023-04-09T00:00:00+00:00",
    
    "mainEntityOfPage":{
      "@type":"WebPage",
      "@id":"https://js970.github.io/unhyeonceje-4-5-suheojjeonri/"
    },
  
}
</script>

  <link rel="stylesheet" href="https://js970.github.io/main.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700">

  <link rel="icon" type="image/png" sizes="32x32" href="https://js970.github.io/assets/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://js970.github.io/assets/favicon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="https://js970.github.io/assets/apple-touch-icon.png">

  
    <link type="application/atom+xml" rel="alternate" href="https://js970.github.io/atom.xml" title="Rounding Off" />
  

  

  
  
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
	integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
	<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
	integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
	<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
	integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
	onload="renderMathInElement(document.body);"></script>

</head>

<body>
  
  <nav class="nav">
    <div class="nav-container">
      <a href="https://js970.github.io/">
        <h2 class="nav-title">Rounding Off</h2>
      </a>
      <ul>
        
          
            <li><a href="https://js970.github.io">Posts</a></li>
          
            <li><a href="https://js970.github.io/tags">Tags</a></li>
          
            <li><a href="https://js970.github.io/about">About</a></li>
          
        
      </ul>
    </div>
  </nav>
  

  <main>
    
  <div class="post">
  	<div class="post-info">
  		<span>Written by</span> JS970<br>
  		
  		<span>on&nbsp;</span><time datetime="2023-04-09">April  9, 2023</time>
  	</div>
  	<h1 class="post-title">운영체제 2023-04-05 수업정리</h1>
  	<div class="post-line"></div>
  	<h1 id="flow">Flow</h1>
<ul>
<li>FCFS Scheduling</li>
<li>SJF Scheduling</li>
<li>Priority Scheduling</li>
<li>Round-Robin Scheduling</li>
<li>Multilevel Queue Scheduling</li>
</ul>
<h2 id="fcfs-scheduling">FCFS Scheduling</h2>
<hr />
<ul>
<li>먼저 도착한 프로세스를 먼저 처리하는 Scheduling Algorithm</li>
<li><strong>non-preemptive</strong> scheduling algorithm이다.</li>
<li>장점(?)
<ul>
<li>구조가 단순하여 구형하기가 매우 쉽다.</li>
<li>Straving이 발생하지 않는 구조이다. 따라서 모든 프로세스의 실행이 보장된다.</li>
</ul>
</li>
<li>단점
<ul>
<li>도착 순서에 따라 waiting time이 크게 달라진다.</li>
<li><code>convey effect</code> 에 따른 문제로 인해 miminum waiting time을 제공하지 못한다.
<ul>
<li><code>convey effect</code> : burst time이 짧은 프로세스가 긴 프로세스 뒤에 위치하는 상황</li>
<li>현실에서는 CPU process, I/O process의 속도 차이가 심하기 때문에 매우 큰 단점으로 다가온다. 이는 burst time이 긴 프로세스가 CPU자원을 내려놓을 때까지 다른 프로세스가 대기해야 하기 때문이다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="example-with-gantt-chart">Example with Gantt Chart</h3>
<p><img src="/image/OS/FCFS.png" alt="FCFS" /></p>
<ul>
<li>Waiting time$$P_1=0,\ P_2=24,\ P_3=27$$</li>
<li>Average Waiting time$$(0+24+27)/3=17$$</li>
<li>앞서 살펴본 것처럼 P1이 먼저 수행될 경우 <code>convey effect</code>에 의해 Average Time이 늘어나는 것을 확인할 수 있다.</li>
<li>만약 , P2, P3, P1순으로 도착하였다면 평군 waiting time 은 아래와 같다.$$(0+3+6)/3=3$$
<ul>
<li>앞서 단점으로 언급한 것처럼 도착 순서에 따라 Average waiting time의 편차가  심한 것을 확인할 수 있다.</li>
</ul>
</li>
</ul>
<h2 id="sjf-scheduling">SJF Scheduling</h2>
<hr />
<ul>
<li>Shortest Job First Scheduling</li>
<li>optimal scheduling solution이다.</li>
<li>프로세스의 도착 순서와 관계없이, burst time이 짧은 것부터 실행하는 scheduling algorithm이다.</li>
<li>Priority가 burst time이 작은 순으로 정렬했을 때의 순서와 같은 Priority Scheduling이다.</li>
<li>두 프로세스의 CPU burst time이 같다면, FCFS scheduling을 사용한다.</li>
<li>SJF는 <strong>preemptive, non-preemptive모두 구현 가능</strong>하다.</li>
</ul>
<h3 id="prediction-of-burst-time">Prediction of Burst Time</h3>
<ul>
<li>SJF는 이론상으로 모든 job들이 최소 waiting time을 가지게 되므로 optimal 하다.</li>
<li>하지만 실제 job의 burst time은 실행 전에 알 수 없다.</li>
<li>따라서 이전 실행시간에 따른 예측값을 burst time으로 사용한다.</li>
<li>이를 위해 Local linear regression을 사용한다.$$t_n\ :\ actual\ length\ of \ n^{th}\ CPU\ burst$$$$\tau_{n+1}\ :\ predicted\ value\ for\ next\ CPU\ burst$$$$\alpha,\ (0\leq\alpha\leq 1)$$$$\tau_{n+1} = \alpha t_n+(1-\alpha)\tau_n$$
<ul>
<li>보통 알파 값은 1/2로 설정된다.</li>
</ul>
</li>
<li>이 공식을 이용해서 실행 시간을 예측해 보면 아래와 같다. 파란색 선은 예측된 burst time, 검은색 선은 실제 burst time이다.<img src="/image/OS/burst_prediction.png" alt="prediction" /></li>
</ul>
<h3 id="example-with-gantt-chart-1">Example with Gantt Chart</h3>
<p><img src="/image/OS/SJF.png" alt="SJF" /></p>
<ul>
<li>Average Waiting Time$$P_1=3,\ P_2=16,\ P_3=9,\ P_4=0\ \ Avg = (3+16+9+0)/4=7$$</li>
</ul>
<h3 id="shortest-time-to-completion-first-stcf">Shortest-Time-to-Completion First(STCF)</h3>
<ul>
<li>SJF가 Preemptive로 동작하는 경우이다.</li>
<li>Preemptive Shortest Job First(PSJF)라고 부르기도 한다.</li>
<li>완료까지 남은 시간이 가장 적은 job을 우선적으로 실행한다.</li>
<li>response time 관련 issue가 있다.(Starving 등)
<ul>
<li>실행시간이 긴 프로세스가 waiting 중일 떄, 계속해서 실행시간이 짧은 프로세스가 ready하게 되면, 실행시간이 긴 프로세스는 영원히 실행되지 않을 것이다.</li>
</ul>
</li>
</ul>
<h2 id="priority-scheduling">Priority Scheduling</h2>
<hr />
<ul>
<li>각 프로세스는 priority값을 가지게 된다.</li>
<li>CPU는 priority가 높은 프로세스를 먼저 처리한다.</li>
<li>priority가 같은 프로세스에 대해서는 FCFS로 처리한다.</li>
<li>priority는 internally, externally로 모두 설정 가능하다.</li>
<li>SJF scheduling은 priority scheduling의 한 종류이다.</li>
<li>Priority Scheduling은 <strong>preemptive, non-preemptive모두 구현 가능</strong>하다.</li>
</ul>
<h3 id="problem">Problem</h3>
<ul>
<li>SJF에서도 다루었듯이, 어떤 프로세스가 낮은 우선순의를 가지고 있을 경우, 해당 프로세스는 영원히 실행되지 않을 수도 있다.
<ul>
<li>이를 <code>indefinite blocking</code> 또는 <code>Starvation</code> 이라고 한다.</li>
</ul>
</li>
<li><code>Starvation</code>은 <code>aging</code>기법으로 해결 가능하다.
<ul>
<li>시스템에서 오랬동안 waiting하는 job의 priority를 점진적으로 증가시키는 것</li>
</ul>
</li>
</ul>
<h3 id="example-with-gantt-chart-2">Example with Gantt Chart</h3>
<p><img src="/image/OS/priority.png" alt="Priority" /></p>
<h2 id="round-robin-rr-scheduling">Round Robin(RR) Scheduling</h2>
<hr />
<ul>
<li>각각의 프로세스는 time quantum(usually 10~100 ns, also known as schedular quantum)동안 실행된다. time quantum이 끝나면 ready queue로 돌아가고 다음 프로세스가 실행된다.</li>
<li>run queue에 있는 job들을 순차적으로 처리한다. run queue는 circular FIFO형태로 구성된다.</li>
<li>run queue의 모든 job들이 끝날 때까지 이를 반복한다.</li>
<li>timer-interrupt에 의해 일어난다. 따라서 time quantum은 timer-interrupt period의 배수여야 한다.</li>
<li><strong>Preemptive Scheduling Algorithm with no Starvation</strong></li>
<li>Starvation문제가 없기 때문에 fair하다. 하지만 Turnaround time 등의 metric 지표에 의하면 좋지 않은 성능을 보인다.</li>
</ul>
<h3 id="biggy">비교</h3>
<ul>
<li>Round Robin Scheduling은 Preemptive Scheduling이지만 Starvation문제로부터 자유롭다.
<ul>
<li><code>aging</code>등의 솔루션이 필요없다.</li>
<li>이는 N개의 job이 있을 때, 어떠한 job이 최소한 n-1개의 job이 실행된 이후에는 실행이 보장되는 특성이 있기 때문에 가능하다.</li>
</ul>
</li>
<li>일반적으로Round Robin은 SJF와 비교하여 response time은 좋은 지표를 보이지만, turnaround에서는 다소 떨어지는 결과를 보여 준다.</li>
<li>time quantum이 큰 값을 가질수록 FCFS와 같은 성능으로 수렴하고, 작은 값을 가질수록 사실상 process sharing(1/n의 속도로 동작)이 된다.
<ul>
<li>context switching time에 의한 성능 오버헤드가 커진다.</li>
<li>이를 고려하여 time quantum은 통상적으로 context switching time이 10us보다 작을 때, 10~100ns정도로 설정하는 것이 적당하다.</li>
<li>또한, time quantum이 너무 작은 값을 가지게 되면 대부분의 프로세스가 여러 번 자신의 차례를 맞이하고 나서 종료되게 된다. 이는 turnaround time을 증가시키는 원인이다.</li>
<li>물론, time quantum이 짧다면 response time을 중요시하는 metric에서는 좋은 지표를 얻을 수 있다.</li>
</ul>
</li>
<li>경험적으로 CPU burst의 80%가량이 time quantum보다 작을 경우 가장 높은 성능을 보인다고 알려져 있다.<img src="/image/OS/maximize.png" alt="maximize utilization" /></li>
</ul>
<h3 id="example-with-gantt-chart-3">Example with Gantt Chart</h3>
<p><img src="/image/OS/roundrobin.png" alt="Round Robin" /></p>
<ul>
<li>Average Waiting Time$$P_1=(0+6),\ P_2=4,\ P_3=7\  Avg = (6+4+7)/3=5.66$$</li>
</ul>
<h2 id="multilevel-queue-scheduling">Multilevel Queue Scheduling</h2>
<hr />
<ul>
<li>Ready Queue를 memory size, process type, process priority등 여러 기준으로 나누어 여러 개를 가진다.
<ul>
<li>response time이 작아야 하는 경우는 RR을 사용</li>
<li>turnaround time을 줄여야 하는 령우 SJF, STCF 사용</li>
<li>foreground process 는 RR scheduling을 사용하고, background process 는 FCFS를 사용하는 것을 예시로 들 수 있다.</li>
</ul>
</li>
<li>각 ready queue들은 fixed priority를 가지거나 Time slice를 바탕으로 동작한다.
<ul>
<li>fixed priority : 각 ready queue마다 priority가 존재하며, 특정 queue의 동작이 모두 처리된 후 다음 priority queue의 동작이 처리된다.
<ul>
<li>Starvation이 발생할 가능성이 있다.</li>
</ul>
</li>
<li>Time Slice : 각 ready queue에 대해 단위 시간 당 일정 비율의 CPU점유를 주는 방식
<ul>
<li>Starvation문제에서 자유롭다.</li>
<li>foreground process에 대해서 time slice가 80%, background process에 대해서 time slice가 20%로 설정하여 scheduling하는 것을 예시로 들 수 있다.(당연하지만 각각의 queue는 별도로 존재하는 상황이다.)</li>
</ul>
</li>
</ul>
</li>
<li>Fixed priority방식으로 MLQ(Multilevel Queue)를 구현했을 경우 Starvation문제를 해결하기 위해 <code>aging</code>을 사용한다.</li>
<li>아래는 fixed priority방식으로 구현한 MLQ의 예시이다.<img src="/image/OS/multilevel.png" alt="Multilevel Queue" />
<ul>
<li>ststem process queue에 있는 process가 가장 먼저 실행되고 나면, 그 다음 priority의 interactive process queue에 있는 process가 실행되는 방식이다.</li>
<li>앞서 설명한 것처럼 starvation의 가능성이 있으므로 <code>aging</code>을 사용해야 한다.(MLFQ)</li>
</ul>
</li>
</ul>
<h3 id="multilevel-feedback-queue-mlfq">Multilevel Feedback Queue(MLFQ)</h3>
<ul>
<li>MLQ에서 각각의 queue에 있던 process들이 다른 level의 queue로 옮겨갈 수 있는 구조이다.
<ul>
<li>따라서 MLFQ는 아래와 같은 method를 추가적으로 제공해야 한다.
<ul>
<li>Method used to when to upgrade a process</li>
<li>Method used to when to demote a process</li>
</ul>
</li>
</ul>
</li>
<li>Example
<img src="/image/OS/MLFQ.png" alt="MLFQ" /></li>
</ul>

  </div>

	

  <div class="pagination">
  	
		<a href="#" class="top">Top</a>
		
  </div>

  </main>

  
  <footer>
    <span>&copy; 2022 JS970. Made with <a href="https://www.getzola.org">Zola</a> using the <a
          href="https://github.com/aaranxu/tale-zola">Tale-Zola</a> theme.</span>
  </footer>
  
</body>
</html>
