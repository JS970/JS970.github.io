<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  
<title>운영체제 2023-03-20 수업정리 | Rounding Off</title>



<meta property="og:title" content="운영체제 2023-03-20 수업정리">



<meta name="author" content="JS970">


<meta property="og:locale" content="en-US">


<meta name="description" content="writing is much easier than remembering">
<meta property="og:description" content="writing is much easier than remembering">



<link rel="canonical" href="https://js970.github.io/unhyeonceje-3-20-suheojjeonri/">
<meta property="og:url" content="https://js970.github.io/unhyeonceje-3-20-suheojjeonri/">



<meta property="og:site_name" content="Rounding Off" />





  <meta property="og:type" content="article" />
  <meta property="article:published_time" content="2023-03-20T00:00:00+00:00">







  <meta name="twitter:card" content="summary">



  <meta property="twitter:title" content="운영체제 2023-03-20 수업정리">








<script type="application/ld+json">
{
  "author": {
    "@type":"Person",
	  "name":"JS970",
  },
  "description": "writing is much easier than remembering",
  "url": "https://js970.github.io/unhyeonceje-3-20-suheojjeonri/",
  "@context":"https://schema.org",
  "@type": "BlogPosting",
  "headline": "운영체제 2023-03-20 수업정리"
  
    
    
      "datePublished":"2023-03-20T00:00:00+00:00",
    
    "mainEntityOfPage":{
      "@type":"WebPage",
      "@id":"https://js970.github.io/unhyeonceje-3-20-suheojjeonri/"
    },
  
}
</script>

  <link rel="stylesheet" href="https://js970.github.io/main.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700">

  <link rel="icon" type="image/png" sizes="32x32" href="https://js970.github.io/assets/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://js970.github.io/assets/favicon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="https://js970.github.io/assets/apple-touch-icon.png">

  
    <link type="application/atom+xml" rel="alternate" href="https://js970.github.io/atom.xml" title="Rounding Off" />
  

  

  
  
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
	integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
	<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
	integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
	<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
	integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
	onload="renderMathInElement(document.body);"></script>

</head>

<body>
  
  <nav class="nav">
    <div class="nav-container">
      <a href="https://js970.github.io/">
        <h2 class="nav-title">Rounding Off</h2>
      </a>
      <ul>
        
          
            <li><a href="https://js970.github.io">Posts</a></li>
          
            <li><a href="https://js970.github.io/tags">Tags</a></li>
          
            <li><a href="https://js970.github.io/about">About</a></li>
          
        
      </ul>
    </div>
  </nav>
  

  <main>
    
  <div class="post">
  	<div class="post-info">
  		<span>Written by</span> JS970<br>
  		
  		<span>on&nbsp;</span><time datetime="2023-03-20">March 20, 2023</time>
  	</div>
  	<h1 class="post-title">운영체제 2023-03-20 수업정리</h1>
  	<div class="post-line"></div>
  	<h1 id="flow">Flow</h1>
<ul>
<li>Process
<ul>
<li>creation</li>
<li>hierarchy</li>
<li>termination</li>
<li>state</li>
</ul>
</li>
<li>Implementing Process</li>
<li>Context Switch</li>
</ul>
<h2 id="process">Process</h2>
<hr />
<h3 id="peurosesseran">프로세스란?</h3>
<p><img src="/image/OS/process_in_memory.png" alt="process in memory" /></p>
<ul>
<li>Program in execution, 즉 실행 중인 프로그램을 프로세스라고 말한다.</li>
<li>프로세스는 아래를 포함한다.
<ul>
<li>CPU contexts(registers) -&gt; 연산상태 저장</li>
<li>Program Counter, Stack Pointer -&gt; 프로그램 실행 정보</li>
<li>OS resources(주소 공간, 파일 포인터 등)</li>
<li>Other informations(PID, state, owner, etc.)</li>
</ul>
</li>
<li>time-shared system에서 보안의 기본 단위가 된다.</li>
<li>프로세스는 유일한 프로세스 식별 넘버인 PID를 통해 식별된다.</li>
<li>한 개의 프로그램은 여러 개의 프로세스로 이루어질 수 있다.</li>
<li>프로세스는 아래와 같이 분류될 수 있다.
<ul>
<li>I/O-bound process : read/write에서 많은 시간을 소요, disk에서의 데이터 처리 속도에 더 많은영향을 받는 프로세스.(system I/O의 속도에 영향을 받는다.)</li>
<li>CPU-bound process : 행렬 곱셈 연산 등 CPU의 처리 속도에 더 많은 영향을 받는 프로세스</li>
</ul>
</li>
</ul>
<h3 id="peurosesse-ssaensseon">프로세스 생성</h3>
<ul>
<li>프로세스 생성 과정
<ol>
<li>프로그램을 코드 영역에서 메모리 및 프로세스 주소 공간으로 load한다.
<ul>
<li>프로그램은 실행 가능한 형태로 디스크 드라이브에 저장되어 있다.</li>
<li>OS는 현재 시점에서 필요한 것들만 <code>lazily</code> 하게 메모리로 load한다.</li>
</ul>
</li>
<li>프로그램의 run time stack을 할당한다.
<ul>
<li>stack영역에는 아래와 같은 값들이 저장된다.
<ul>
<li>local variables</li>
<li>function parameters</li>
<li>return address</li>
</ul>
</li>
</ul>
</li>
<li>프로그램 heap을 생성한다.
<ul>
<li>heap에는 명시적으로 동적 할당되어 사용되는 데이터들이 저장된다.</li>
<li>C언어에서는 malloc()을 호출하여 공간을 할당하고 free()를 호출하여 공간을 해제할 수 있다.</li>
</ul>
</li>
<li>OS는 위에서 언급한 것 이외의 초기화 동작을 수행한다.
<ul>
<li>Input/Output setup - 프로세스는 기본적으로 세 개의 open file descriptor를 가진다.
<ul>
<li>standard input, output, error</li>
</ul>
</li>
</ul>
</li>
<li>프로그램의 시작 지점(entry point, main())에서부터 프로그램을 실행한다.
<ul>
<li>OS는 CPU점유를 새롭게 생성된 프로세스로 넘겨준다.</li>
</ul>
</li>
</ol>
</li>
<li>fork()
<ul>
<li>프로세스를 생성하는 system call이다. 부모 프로세스를 복제한다.</li>
<li>부모 프로세스는 대부분의 자원 및 privileges를 공유한다.(open files, UID, etc.)</li>
<li>자식 프로세스는 부모 프로세스의 주소 공간도 복제한다.</li>
<li>부모 프로세스는 wait()을 이용하여 자식 프로세스의 수행이 끝날 때까지 대기할 수 있다.</li>
<li>wait()을 사용하지 않았다면 자식 프로세스와 부모 프로세스는 병렬 수행된다.</li>
<li>Shell 또는 GUI는 이 system call을 자체적으로 사용한다.</li>
</ul>
</li>
<li>exec()
<ul>
<li>현재 프로세스를 새로운 프로그램으로 교체한다.(system call 호출 즉시 자원을 점유한다.)</li>
<li>Windows 운영체제 에서는 CreateProcess() system call이 fork() + exec() 동작을 수행한다.</li>
</ul>
</li>
</ul>
<h3 id="peurosesse-ggyceung-gujo">프로세스 계층 구조</h3>
<ul>
<li>아래는 유닉스 환경에서 프로세스의 계층 구조를 쉽게 이해하기 위한 도식이다.</li>
</ul>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#bf616a;">cat</span><span> file1 | </span><span style="color:#bf616a;">wc
</span></code></pre>
<p><img src="/image/OS/hierarchy.png" alt="process hierarchy" /></p>
<ul>
<li>shell이 parent process 이고 shell에서 실행된 cat, wc는 child process이다.</li>
<li>Unix에서는 이러한 계층 구조를 <code>process group</code>이라고 한다.</li>
<li>Windows에서는 이러한 계층 구조 개념이 존재하지 않는다.</li>
</ul>
<h3 id="peurosesse-jjonryo">프로세스 종료</h3>
<ul>
<li>Normal exit(voluntary) : 할 일을 모두 수행하고 return하여 프로세스를 종료하는 경우</li>
<li>Error exit(voluntary) : error가 발생하여 프로세스를 종료하는 경우</li>
<li>Fatal error(involuntary) : operating system 규칙 윙반, 권한 침범으로 인한 kill process
<ul>
<li>Segmentation fault</li>
<li>Protection fault</li>
<li>Exceed allocated resources, etc.</li>
</ul>
</li>
<li>Killed by another process(involuntary) : 특정 신호 수신 등 다른 프로세스를 통해 프로세스가 종료되는 경우
<ul>
<li>Ctrl + C</li>
</ul>
</li>
<li>Zombie process : 프로세스는 종료되었지만 제거되지 않은 상태</li>
</ul>
<h3 id="peurosesse-state">프로세스 state</h3>
<p><img src="/image/OS/process_state.png" alt="process states" /></p>
<ul>
<li>New : 프로세스가 생성되는 상태, fork()로 인해 새롭게 프로세스가 생성되는 것을 생각할 수 있다.</li>
<li>Running : 프로그램의 명령어들이 실행되고 있는 상태, exec()를 통해 프로세스가 CPU를 점유한 상태를 생각할 수 있다.</li>
<li>Waiting : 프로세스가 어떠한 이벤트를 기다리고 있는 상태, wait()에 의해 부모 프로세스가 자식 프로세스의 종료를 기다리는 상황을 생각할 수 있다.</li>
<li>Ready : 프로세스가 프로세서 자원을 할당받기를 대기하는 상태, OS에 의해 실행될 때까지 대기하는 상태이다.</li>
<li>Terminated : 프로세스가 실행을 종료한 상태이다. exit()에 의해 프로세스 종료가 일어난 상황을 생각할 수 있다.</li>
</ul>
<h2 id="implementing-process">Implementing Process</h2>
<hr />
<ul>
<li>프로세스의 구현은 PCB(Process Control Block)자료 구조를 통해 이뤄진다.</li>
<li>PCB는 TCB라고도 불린다(Task Control Block)</li>
<li>아래는 TCB를 간단하게 설명하는 그림이다.
<img src="/image/OS/tcb.png" alt="tcb" /></li>
<li>대략적으로 아래와 같은 정보들이 TCB자료 구조에 저장되어 프로세스 상태를 나타낸다.
<ul>
<li>Process state : running, waiting 등 process state정보를 저장</li>
<li>Program Counter : 다음 실행될 명령어의 위치 저장</li>
<li>CPU register : 연산 상태를 저장하는 CPU 레지스터</li>
<li>CPU scheduling informations : 우선순위 및 scheduling queue pointers</li>
<li>Memory management information : CPU used, clock time elapsed since start, etc.</li>
<li>I/O status</li>
<li>etc.</li>
</ul>
</li>
<li>TCB는 프로세스 마다 다를 수 있는 거의 모든 정보들을 저장하고 있다고 생각하면 된다.</li>
<li>Linux 3.2.0기준으로 TCB는 task_struct 로 구현되었으며 이 구조체의 크기는 3248바이트로 굉장히 큰 크기를 가진다.</li>
</ul>
<h2 id="context-switch">Context Switch</h2>
<hr />
<ul>
<li>CPU의 프로세스에서 다른 프로세스로 CPU의 점유를 넘기는 것</li>
<li>일반적으로 CPU에서는 초당 100 ~ 1000 회의 context switch가 발생한다.</li>
<li>필연적으로 overhead가 발생한다. context switch횟수를 줄일 수록 성능 향상이 있다.</li>
<li>아래는 context switch 간에 overhead가 발생하는 이유를 설명하는 도식이다.
<img src="/image/OS/context_switching.png" alt="context switch" /></li>
</ul>

  </div>

	

  <div class="pagination">
  	
		<a href="#" class="top">Top</a>
		
  </div>

  </main>

  
  <footer>
    <span>&copy; 2022 JS970. Made with <a href="https://www.getzola.org">Zola</a> using the <a
          href="https://github.com/aaranxu/tale-zola">Tale-Zola</a> theme.</span>
  </footer>
  
</body>
</html>
