<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  
<title>Deadlock(2) | Rounding Off</title>



<meta property="og:title" content="Deadlock(2)">



<meta name="author" content="JS970">


<meta property="og:locale" content="en-US">


<meta name="description" content="writing is much easier than remembering">
<meta property="og:description" content="writing is much easier than remembering">



<link rel="canonical" href="https://js970.github.io/deadlock-2/">
<meta property="og:url" content="https://js970.github.io/deadlock-2/">



<meta property="og:site_name" content="Rounding Off" />





  <meta property="og:type" content="article" />
  <meta property="article:published_time" content="2023-05-03T00:00:00+00:00">







  <meta name="twitter:card" content="summary">



  <meta property="twitter:title" content="Deadlock(2)">








<script type="application/ld+json">
{
  "author": {
    "@type":"Person",
	  "name":"JS970",
  },
  "description": "writing is much easier than remembering",
  "url": "https://js970.github.io/deadlock-2/",
  "@context":"https://schema.org",
  "@type": "BlogPosting",
  "headline": "Deadlock(2)"
  
    
    
      "datePublished":"2023-05-03T00:00:00+00:00",
    
    "mainEntityOfPage":{
      "@type":"WebPage",
      "@id":"https://js970.github.io/deadlock-2/"
    },
  
}
</script>

  <link rel="stylesheet" href="https://js970.github.io/main.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700">

  <link rel="icon" type="image/png" sizes="32x32" href="https://js970.github.io/assets/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://js970.github.io/assets/favicon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="https://js970.github.io/assets/apple-touch-icon.png">

  
    <link type="application/atom+xml" rel="alternate" href="https://js970.github.io/atom.xml" title="Rounding Off" />
  

  

  
  
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
	integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
	<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
	integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
	<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
	integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
	onload="renderMathInElement(document.body);"></script>

</head>

<body>
  
  <nav class="nav">
    <div class="nav-container">
      <a href="https://js970.github.io/">
        <h2 class="nav-title">Rounding Off</h2>
      </a>
      <ul>
        
          
            <li><a href="https://js970.github.io">Posts</a></li>
          
            <li><a href="https://js970.github.io/tags">Tags</a></li>
          
            <li><a href="https://js970.github.io/about">About</a></li>
          
        
      </ul>
    </div>
  </nav>
  

  <main>
    
  <div class="post">
  	<div class="post-info">
  		<span>Written by</span> JS970<br>
  		
  		<span>on&nbsp;</span><time datetime="2023-05-03">May  3, 2023</time>
  	</div>
  	<h1 class="post-title">Deadlock(2)</h1>
  	<div class="post-line"></div>
  	<h2 id="deadlock-handling-deadlock-prevention">Deadlock Handling - Deadlock Prevention</h2>
<hr />
<ul>
<li>deadlock condition중 최소 한 가지 이상의 조건을 만족하지 않도록 설정하여 deadlock을 예방하는 방법</li>
<li>Computational Overhead가 너무 커서 실제로 사용하지는 않는다.</li>
<li>본 절에서는 방법론에 대해서만 다룬다.</li>
</ul>
<h3 id="mutual-exclusion">Mutual Exclusion</h3>
<ul>
<li>shared resources를 require하지 않고 nonsharable resource만 hold하는 방법으로 구현한다.</li>
<li>일반적으로 Mutual Exclusion을 부정하는 방법으로는 deadlock prevent를 할 수 없다.
<ul>
<li>일부 자원의 경우 애초부터 non-sharable이기 때문</li>
</ul>
</li>
</ul>
<h3 id="hold-and-wait">Hold and Wait</h3>
<ul>
<li>어떤 프로세스든 자원을 request할 때는 어떠한 resource도 hold하지 않는 것을 보장한다.</li>
<li>오버헤드가 너무 크다.(Low resource utilization문제가 있다)</li>
<li>starvation이 발생할 가능성이 있다.</li>
</ul>
<h3 id="no-preemption">No Preemption</h3>
<ul>
<li>어떤 프로세스가 자원을 holding하고 있으면서 request할 때, 곧바로 할당받는 것이 아니라 모든 resource를  release한 후에 자원을 할당받는다.</li>
<li>프로세스는 모든 자원을 확보한 후에야 실행 가능하다.
<ul>
<li>결과적으로 한번의 request를 통해 필요한 자원을 확보애햐 한다</li>
</ul>
</li>
<li>Preemptive동작을 하는 것과 동일한 효과이다.</li>
</ul>
<h3 id="circular-wait">Circular Wait</h3>
<ul>
<li>waiting이 circular cycle을 형성하지 않도록 한다.</li>
<li>process, resource가 increasing order로만 request가능하도록 설정한다.</li>
<li>P3는 P1이 점유중인 자원에 대해 request할 수 없는 rule을 만들어서 구현하는 방식이다.</li>
</ul>
<h2 id="deadlock-handling-deadlock-avoidance">Deadlock Handling - Deadlock Avoidance</h2>
<hr />
<ul>
<li>Deadlock Avoidance를 구현하기 위해서 시스템은 아래와 같은 사전 정보를 필요로 한다.
<ul>
<li>Resource currently available</li>
<li>The resources currently allocated to each process</li>
<li>The future requests and releases of each process</li>
</ul>
</li>
<li>Deadlock Avoidance는 앞서 설명한 사전 정보들을 이용해서 circular-wait condition을 형성하는 자원 할당이 이루어지지 않도록 dynamically examines하는 알고리즘이다.</li>
</ul>
<h3 id="safe-state">Safe State</h3>
<ul>
<li>데드락을 발생시키지 않는 상태
<ul>
<li><code>unsafe</code>의 경우 데드락이 생길 수도 있고, 생기지 않을 수도 있다.</li>
</ul>
</li>
<li>프로세스가 자원 할당을 요청할 때, 시스템은 immediate allocation이 시스템의 <code>safe state</code>에 영향을 미칠지를 판단해야 한다.</li>
<li>만약 시스템의 모든 프로세스에 대해 P0, P1, P2, ..., Pn의 sequence가 존재한다면 시스템은 <code>safe State</code>에 있다고 한다.
<ul>
<li>시스템의 모든 프로세스 request에 대해 데드락을 발생시키지 않는 프로세스의 sequence가 있다면 시스템은<code>safe state</code> 이다.</li>
</ul>
</li>
</ul>
<h3 id="deadlock-avoidance-strategy">Deadlock Avoidance Strategy</h3>
<ul>
<li>Deadlock Avoidance를 위해서는 아래와 같은 사항을 생각해야 한다.
<ul>
<li>현재 시점에서 <code>safe state</code>여야 한다.</li>
<li>request가 온 이후에도 <code>safe state</code>여야 한다.
<ul>
<li>request가 온 것으로 가정(pretend)하고 deadlock이 발생할지 판단한다.</li>
<li>이는 미래에 올 request를 알고 있기 때문에 가능하다.</li>
</ul>
</li>
</ul>
</li>
<li>자원이 한 개의 인스턴스로만 이루어질 때는 <code>resource-allocation graph</code>를 사용한다.</li>
<li>자원이 여러 개의 인스턴스 타입을 가질 때는 <code>Banker's Algorithm</code>을 사용한다.</li>
</ul>
<h3 id="resource-allocation-graph-scheme">Resource-Allocation graph Scheme</h3>
<ul>
<li>자원이 한 개의 인스턴스로만 이루어질 경우 Deadlock Avoidance를 위해 사용한다.</li>
<li><code>claim edge</code> : Pi가 Rj를 request할 지도 모른다는 것을 점선으로 표시한다.
<ul>
<li>할당된 자원이 해제되면 <code>assignment edge</code>는 <code>claim edge</code>로 변경된다.</li>
</ul>
</li>
<li><code>request edge</code> : 실제로 프로세스가 자원을 request할 경우
<ul>
<li><code>claim edge</code>의 Pi가 실제로 Rj를 request하면 <code>request edge</code>로 변경된다.</li>
</ul>
</li>
<li><code>assignment edge</code> : 자원이 실제로 프로세스에 할당된 경우
<ul>
<li>request에 따라 자원이 할당되면 <code>request edge</code>는 <code>assignment edge</code>로 변경된다.</li>
</ul>
</li>
<li>자원 할당은 claim -&gt; request -&gt; assignment의 과정을 거친다.<img src="/image/OS/graphAvoidance.png" alt="Resource-Allocation Graph Scheme" />
<ul>
<li>항상 claim을 처리하는 것이 아닌, claim 요청을 통해 cycle이 생성되지 않는 경우에만 request를 통해 assignment를 수행한다.</li>
<li>잠정적으로 deadlock을 발생시킬 수 있는 cycle이 발생하면 request를 처리하지 않는다.</li>
<li>위 도식에서 P2는 R2를 claim하지만, 이 <code>claim edge</code>가 <code>request edge</code>로 변경되면 cycle이 생성되므로 이는 request되지 않는다.</li>
</ul>
</li>
</ul>
<h3 id="banker-s-algorithm">Banker's Algorithm</h3>
<ul>
<li>자원이 여러 개의 인스턴스 타입으로 이루어질 경우 Deadlock Avoidance를 위해 사용된다.</li>
<li>Banker's Algorithm 용어 정리
<ul>
<li><code>n</code> : 프로세스의 개수</li>
<li><code>m</code> : resource 인스턴스의 개수</li>
<li><code>available[j] = k</code> : Rj는 k개의 인스턴스에 할당 가능하다.</li>
<li><code>Max[i, j] = k</code> : Pi는 최대 Rj에 최대 k개의 인스턴스를 요청할 것이다.</li>
<li><code>Allocation[i, j] = k</code> : Pi는 Rj로부터 k개의 인스턴스를 할당받은 상태이다.</li>
<li><code>Need[i, j] = k</code> : Pi는 task 수행을 완료하기 위해 Rj에 k개(이상)의 인스턴스를 요청할 것이다.
<ul>
<li>Need[i, j] = Max[i, j] - Allocation[i , j]</li>
</ul>
</li>
</ul>
</li>
<li>Safety Algorithm
<ol>
<li><code>Work</code> : m크기의 벡터, <code>Finish</code> : n크기의 백터. 
<ul>
<li><code>Work</code> = <code>Available</code>, <code>Finish[i] = false</code>로 초기화한다.</li>
</ul>
</li>
<li><code>Finish[i] == false</code> 이고, <code>Need[i] &lt;= Work</code>인 i를 찾는다. 만약 이러한 i가 없다면 4로 간다.</li>
<li><code>Work</code> = <code>Work</code> + <code>Allocation[i]</code>, <code>Finish[i] = true</code>, 2로 돌아간다.</li>
<li>만약 모든 i에 대해<code>Finish[i] == true</code> 라면 시스템은 <code>safe state</code>이다.</li>
</ol>
</li>
<li>Resource-Request Algorithm for Pi
<ul>
<li><code>Request[i, j]</code> : Pi의 Rj로의 request vector
<ul>
<li><code>Request[i, j] = k</code>라면 Pi가 Rj의 인스턴스 k개를 요청하는 것이다.</li>
</ul>
</li>
</ul>
<ol>
<li>만약 <code>Request[i, j] &lt;= Need[i]</code> 라면 2로 넘어간다. 이외의 경우 에러를 발생시킨다.</li>
<li>만약 <code>Request[i, j] &lt;= Available[j]</code> 라면 3으로 넘어간다. 
<ul>
<li>이외의 경우 자원 할당이 불가능하므로 대기해야 한다. </li>
</ul>
</li>
<li>Pi에 자원 할당을 하는 것처럼 아래와 같이 시뮬레이션 한다.(pretend to allocate)
<ul>
<li><code>Available[j]</code> = <code>Available[j]</code> - <code>Request[i]</code></li>
<li><code>Allocation[i]</code> = <code>Allocation[i]</code> + <code>Request[i]</code></li>
<li><code>Need[i]</code> = <code>Need[i]</code> - <code>Request[i]</code></li>
</ul>
</li>
</ol>
<ul>
<li>위의 과정을 모든 프로세스에 대헤 진행하여 safe하다면 Pi에 자원을 할당한다.</li>
<li>unsafe라면 Pi는 선행 프로세스가 자원 할당을 해제할 때까지 대기해야 한다.</li>
</ul>
</li>
<li>Banker's Algorithm 동작
<ol>
<li>Request에 대해 <code>Resource-Request Algorithm</code>을 수행한다.</li>
<li><code>Safety Algorithm</code>을 수행하여 <code>safe state</code>를 검사한다.</li>
</ol>
</li>
<li>Deadlock Avoidance에서는 <code>Need</code>정보를 바탕으로 <code>safe sequence</code>가 존재하는지 검사한다. 
<ul>
<li><code>safe sequence</code> 가 존재한다면 Deadlock Avoidance가 되는 것이다.</li>
<li><code>safe sequence</code>가 존재하지 않는다면 <code>unsafe</code>이다.</li>
</ul>
</li>
</ul>
<h2 id="deadlock-handling-deadlock-detection">Deadlock Handling - Deadlock Detection</h2>
<hr />
<ul>
<li>앞서 살펴본 Deadlock Prevention, Deadlock Avoidance는 오버헤드가 너무 커서 실제로는 사용하지 않는 Deadlock 해결 방법이다.</li>
<li>실제로는 Deadlock을 허용하고, 이를 탐지하여 처리하는 방법인 Deadlock Detection을 사용한다.
<ul>
<li>이 방법 역시 오버헤드가 적지는 않지만 앞선 두 방법보다는 확실히 현실적이다.</li>
</ul>
</li>
<li>자원이 한 개의 인스턴스로 이루어진 경우 <code>request-allocation graph</code>를 변형한 <code>wait-for graph</code>를 사용한다.</li>
<li>자원이 여러 개의 인스턴스로 이루어진 경우 <code>변형된 banker's algorithm</code>을 사용한다.</li>
</ul>
<h3 id="wait-for-graph">Wait-for graph</h3>
<p><img src="/image/OS/waitForGraph.png" alt="Wait - For Graph" /></p>
<ul>
<li>앞서 다루었던 <code>resource-allocation graph</code>를 통해 <code>wait-for graph</code>를 만들 수 있다.</li>
<li><code>resource</code> 를 고려하지 않고 프로세스 간의 관계만 고려한다.
<ul>
<li>자원이 한 개의 인스턴스로 이루어졌으므로 이것이 가능하다.</li>
</ul>
</li>
</ul>
<h3 id="variant-of-the-banker-s-algorithm">Variant of the Banker's Algorithm</h3>
<ul>
<li>Deadlock Avoidance가 목적이 아니라 Deadlock Detection이 목적이다.</li>
<li><code>Need[i]</code>에 대해서는 생각하지 않고, 순간 순간의 <code>Request[i]</code>를 처리할 수 있는지 판단한다.</li>
<li>모든 <code>Request</code>가 처리되는 <code>sequence</code>가 존재한다면 해당 시스템에서는 Deadlock이 탐지되지 않은 것이다.
<ul>
<li>이는 <code>Request</code>의 순서를 다루는 것이므로 <code>safe sequence</code>와는 다른 개념이다.</li>
</ul>
</li>
<li>만약 <code>Work[i]</code>상태에서 처리할 수 있는 <code>Request[i]</code>가 없다면, <code>Finish == false</code>인 모든 프로세스가 Deadlock을 유발하는 프로세스이다.</li>
<li><code>Finish == false</code>로 Deadlock을 유발하는 프로세스들에 대해서 <code>Process Termination</code>혹은 <code>Resource Preemption</code>을 통해 Deadlock Recovery를 수행한다.</li>
</ul>
<h3 id="recovery-shceme-process-termination">Recovery shceme : Process Termination</h3>
<ul>
<li>Deadlock이 Detection된 경우 프로세스를 종료시키는 방법</li>
<li>한 번에 프로세스를 하나씩 abort하면서 deadlock이 없어지는지(cycle이 없어지는지)확인한다.</li>
<li>경우에 따라 다르지만 아래와 같은 기준으로 abort순서를 정한다.
<ul>
<li>프로세스의 priority</li>
<li>프로세스가 얼마나 오래 실행되었는지, 혹은 실행시간이 얼마나 남았는지</li>
<li>프로세스가 사용한 자원의 양</li>
</ul>
</li>
</ul>
<h3 id="recovery-scheme-resource-preemption">Recovery Scheme : Resource Preemption</h3>
<ul>
<li><code>victim</code>을 선택한다.(minimize cost)</li>
<li><code>safe state</code>로 돌아간 뒤 해당 상태에서 다시 프로세스를 실행시킨다.</li>
<li>이 과정에서 cost를 줄이는 방향으로 <code>victim</code>을 선정하게 되면 특정 프로세스가 계속 <code>victim</code>이 되어 <code>starvation</code>문제가 발생할 수 있다.
<ul>
<li>딱히 권장하는 방법은 아니다.</li>
</ul>
</li>
</ul>

  </div>

	

  <div class="pagination">
  	
		<a href="#" class="top">Top</a>
		
  </div>

  </main>

  
  <footer>
    <span>&copy; 2022 JS970. Made with <a href="https://www.getzola.org">Zola</a> using the <a
          href="https://github.com/aaranxu/tale-zola">Tale-Zola</a> theme.</span>
  </footer>
  
</body>
</html>
