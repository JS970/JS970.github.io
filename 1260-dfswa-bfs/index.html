<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  
<title>1260 - DFS와 BFS | Rounding Off</title>



<meta property="og:title" content="1260 - DFS와 BFS">



<meta name="author" content="JS970">


<meta property="og:locale" content="en-US">


<meta name="description" content="writing is much easier than remembering">
<meta property="og:description" content="writing is much easier than remembering">



<link rel="canonical" href="https://js970.github.io/1260-dfswa-bfs/">
<meta property="og:url" content="https://js970.github.io/1260-dfswa-bfs/">



<meta property="og:site_name" content="Rounding Off" />





  <meta property="og:type" content="article" />
  <meta property="article:published_time" content="2023-02-23T00:00:00+00:00">







  <meta name="twitter:card" content="summary">



  <meta property="twitter:title" content="1260 - DFS와 BFS">








<script type="application/ld+json">
{
  "author": {
    "@type":"Person",
	  "name":"JS970",
  },
  "description": "writing is much easier than remembering",
  "url": "https://js970.github.io/1260-dfswa-bfs/",
  "@context":"https://schema.org",
  "@type": "BlogPosting",
  "headline": "1260 - DFS와 BFS"
  
    
    
      "datePublished":"2023-02-23T00:00:00+00:00",
    
    "mainEntityOfPage":{
      "@type":"WebPage",
      "@id":"https://js970.github.io/1260-dfswa-bfs/"
    },
  
}
</script>

  <link rel="stylesheet" href="https://js970.github.io/main.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700">

  <link rel="icon" type="image/png" sizes="32x32" href="https://js970.github.io/assets/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://js970.github.io/assets/favicon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="https://js970.github.io/assets/apple-touch-icon.png">

  
    <link type="application/atom+xml" rel="alternate" href="https://js970.github.io/atom.xml" title="Rounding Off" />
  

  

  
  
</head>

<body>
  
  <nav class="nav">
    <div class="nav-container">
      <a href="https://js970.github.io/">
        <h2 class="nav-title">Rounding Off</h2>
      </a>
      <ul>
        
          
            <li><a href="https://js970.github.io">Posts</a></li>
          
            <li><a href="https://js970.github.io/tags">Tags</a></li>
          
            <li><a href="https://js970.github.io/about">About</a></li>
          
        
      </ul>
    </div>
  </nav>
  

  <main>
    
  <div class="post">
  	<div class="post-info">
  		<span>Written by</span> JS970<br>
  		
  		<span>on&nbsp;</span><time datetime="2023-02-23">February 23, 2023</time>
  	</div>
  	<h1 class="post-title">1260 - DFS와 BFS</h1>
  	<div class="post-line"></div>
  	<ul>
<li>난이도: 실버 2</li>
<li>날짜: 2023년 2월 23일</li>
<li>상태: Correct/Retry</li>
<li>추가 검토 여부: Yes</li>
<li>알고리즘 : DFS, BFS, Graph</li>
</ul>
<h1 id="solution">solution</h1>
<ul>
<li>
<p>DFS와 BFS를 조건에 맞게 구현하기만 하면 되는 문제이다.</p>
</li>
<li>
<p>DFS, BFS의 개념은 자료 구조 수업에서 배웠다고 생각했지만 막상 구현하려고 하니 어려움이 많았다.</p>
</li>
<li>
<p>결국 구현의 핵심은 adjacency list와 visited list의 사용이었다.</p>
</li>
<li>
<p>각 블로그 및 교재를 참조하였으나 잘 이해가 되지 않아서… chat GPT에게 코드를 요청했고 그 코드를 바탕으로 학습하였다.</p>
</li>
<li>
<p>아래는 DFS와 BFS의 chat GPT코드의 개념이다.</p>
<ul>
<li>DFS</li>
</ul>
<p><img src="/image/baekjoon/DFS.png" alt="DFS" /></p>
<ul>
<li>인접 리스트의 첫 번째 원소부터 접근하여 해당 노드가 visited == false인 경우 그 노드를 시작 노드로 가지는 DFS를 호출한다. 이러한 방식으로 첫 번째 호출된 DFS의 시작 노드에 대한 모든 adjacency list에 대한 탐색을 모두 마치면 함수가 종료된다.</li>
<li>BFS</li>
</ul>
<p><img src="/image/baekjoon/BFS.png" alt="BFS" /></p>
<ul>
<li>앞선 DFS는 함수의 재귀 호출을 통해 구현했다면 BFS는 while loop과 queue를 통해 구현했다. start node에서 시작하여 한 번의 루프마다 queue에서 pop을 수행한다. queue에서 pop 된 후 pop된 노드에 대한 인접 리스트를 탐색한다. 인접 리스트의 원소가 visited == false인 경우 해당 노드를 queue에 push한다. 이런 방식으로 queue가 empty가 아니라면 계속해서 while문을 수행한다. queue를 통해 계층 별로 순서에 맞게 탐색하는 BFS를 구현할 수 있다.</li>
</ul>
</li>
<li>
<p>DFS, BFS와 별개로 본 문제에서 요구한 사항인 방문 가능한 노드가 다수 있을 경우 번호가 작은 노드를 먼저 방문해야 한다는 조건에 따라 adjacency list를 오름차순으로 정렬해 주어야 했다.</p>
<ul>
<li>이는 algorithm 헤더의 sort method를 이용하여 구현하였다.</li>
<li>본 문제에서 노드 번호는 1부터 시작하는데 이를 간과한 채 sort함수를 실행하여 segmentation fault로 한번 오답을 제출했다. 범위를 바꿔 주니 정답을 출력했다.</li>
</ul>
</li>
</ul>
<h1 id="code">code</h1>
<ul>
<li>
<p>chat GPT 코드 - give me c++ code implementing DFS and BFS algorithm</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">vector</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">queue</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">stack</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">using namespace</span><span> std;
</span><span>
</span><span style="color:#65737e;">// function to perform Depth First Search (DFS)
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">dfs</span><span>(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">node</span><span>, vector&lt;</span><span style="color:#b48ead;">int</span><span>&gt; </span><span style="color:#bf616a;">adj</span><span>[], vector&lt;</span><span style="color:#b48ead;">bool</span><span>&gt;&amp; </span><span style="color:#bf616a;">visited</span><span>) {
</span><span>    visited[node] = </span><span style="color:#d08770;">true</span><span>;
</span><span>    cout &lt;&lt; node &lt;&lt; &quot; &quot;;
</span><span>
</span><span>    </span><span style="color:#b48ead;">for</span><span>(</span><span style="color:#b48ead;">int</span><span> i = </span><span style="color:#d08770;">0</span><span>; i &lt; adj[node].</span><span style="color:#bf616a;">size</span><span>(); i++) {
</span><span>        </span><span style="color:#b48ead;">int</span><span> neighbor = adj[node][i];
</span><span>        </span><span style="color:#b48ead;">if</span><span>(!visited[neighbor]) {
</span><span>            </span><span style="color:#bf616a;">dfs</span><span>(neighbor, adj, visited);
</span><span>        }
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#65737e;">// function to perform Breadth First Search (BFS)
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">bfs</span><span>(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">start</span><span>, vector&lt;</span><span style="color:#b48ead;">int</span><span>&gt; </span><span style="color:#bf616a;">adj</span><span>[], vector&lt;</span><span style="color:#b48ead;">bool</span><span>&gt;&amp; </span><span style="color:#bf616a;">visited</span><span>) {
</span><span>    queue&lt;</span><span style="color:#b48ead;">int</span><span>&gt; q;
</span><span>    visited[start] = </span><span style="color:#d08770;">true</span><span>;
</span><span>    q.</span><span style="color:#bf616a;">push</span><span>(start);
</span><span>
</span><span>    </span><span style="color:#b48ead;">while</span><span>(!q.</span><span style="color:#bf616a;">empty</span><span>()) {
</span><span>        </span><span style="color:#b48ead;">int</span><span> node = q.</span><span style="color:#bf616a;">front</span><span>();
</span><span>        q.</span><span style="color:#bf616a;">pop</span><span>();
</span><span>        cout &lt;&lt; node &lt;&lt; &quot; &quot;;
</span><span>
</span><span>        </span><span style="color:#b48ead;">for</span><span>(</span><span style="color:#b48ead;">int</span><span> i = </span><span style="color:#d08770;">0</span><span>; i &lt; adj[node].</span><span style="color:#bf616a;">size</span><span>(); i++) {
</span><span>            </span><span style="color:#b48ead;">int</span><span> neighbor = adj[node][i];
</span><span>            </span><span style="color:#b48ead;">if</span><span>(!visited[neighbor]) {
</span><span>                visited[neighbor] = </span><span style="color:#d08770;">true</span><span>;
</span><span>                q.</span><span style="color:#bf616a;">push</span><span>(neighbor);
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">int</span><span> n, m;
</span><span>    cin &gt;&gt; n &gt;&gt; m; </span><span style="color:#65737e;">// n: number of nodes, m: number of edges
</span><span>
</span><span>    vector&lt;</span><span style="color:#b48ead;">int</span><span>&gt; adj[n+</span><span style="color:#d08770;">1</span><span>]; </span><span style="color:#65737e;">// adjacency list
</span><span>
</span><span>    </span><span style="color:#65737e;">// build the graph
</span><span>    </span><span style="color:#b48ead;">for</span><span>(</span><span style="color:#b48ead;">int</span><span> i = </span><span style="color:#d08770;">0</span><span>; i &lt; m; i++) {
</span><span>        </span><span style="color:#b48ead;">int</span><span> u, v;
</span><span>        cin &gt;&gt; u &gt;&gt; v;
</span><span>        adj[u].</span><span style="color:#bf616a;">push_back</span><span>(v);
</span><span>        adj[v].</span><span style="color:#bf616a;">push_back</span><span>(u);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#65737e;">// initialize visited array
</span><span>    vector&lt;</span><span style="color:#b48ead;">bool</span><span>&gt; </span><span style="color:#bf616a;">visited</span><span>(n+</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">false</span><span>);
</span><span>
</span><span>    </span><span style="color:#65737e;">// perform DFS
</span><span>    </span><span style="color:#b48ead;">for</span><span>(</span><span style="color:#b48ead;">int</span><span> i = </span><span style="color:#d08770;">1</span><span>; i &lt;= n; i++) {
</span><span>        </span><span style="color:#b48ead;">if</span><span>(!visited[i]) {
</span><span>            </span><span style="color:#bf616a;">dfs</span><span>(i, adj, visited);
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#65737e;">// reset visited array
</span><span>    visited.</span><span style="color:#bf616a;">assign</span><span>(n+</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">false</span><span>);
</span><span>
</span><span>    </span><span style="color:#65737e;">// perform BFS
</span><span>    </span><span style="color:#b48ead;">for</span><span>(</span><span style="color:#b48ead;">int</span><span> i = </span><span style="color:#d08770;">1</span><span>; i &lt;= n; i++) {
</span><span>        </span><span style="color:#b48ead;">if</span><span>(!visited[i]) {
</span><span>            </span><span style="color:#bf616a;">bfs</span><span>(i, adj, visited);
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<ul>
<li>놀랍게도…? syntax error가 있다(2023/02/23). 벡터 선언에 있어 lvalue 가지고 동적 할당이 아니라 바로 선언을 해버렸다. 아래의 제출 코드는 이 문법 문제를 동적 할당으로 바꾸어 해결했다.</li>
</ul>
</li>
<li>
<p>제출 코드</p>
</li>
</ul>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">vector</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">queue</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">algorithm</span><span>&gt;
</span><span style="color:#b48ead;">using namespace</span><span> std;
</span><span>
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">dfs</span><span>(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">node</span><span>, vector&lt;</span><span style="color:#b48ead;">int</span><span>&gt; </span><span style="color:#bf616a;">adj</span><span>[], vector&lt;</span><span style="color:#b48ead;">bool</span><span>&gt;&amp; </span><span style="color:#bf616a;">visited</span><span>)
</span><span>{
</span><span>    visited[node] = </span><span style="color:#d08770;">true</span><span>;
</span><span>    cout &lt;&lt; node &lt;&lt; &quot; &quot;;
</span><span>
</span><span>    </span><span style="color:#b48ead;">for</span><span>(</span><span style="color:#b48ead;">int</span><span> i = </span><span style="color:#d08770;">0</span><span>; i &lt; adj[node].</span><span style="color:#bf616a;">size</span><span>(); i++)
</span><span>    {
</span><span>        </span><span style="color:#b48ead;">int</span><span> neighbor = adj[node][i];
</span><span>        </span><span style="color:#b48ead;">if</span><span>(!visited[neighbor])
</span><span>            </span><span style="color:#bf616a;">dfs</span><span>(neighbor, adj, visited);
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">bfs</span><span>(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">start</span><span>, vector&lt;</span><span style="color:#b48ead;">int</span><span>&gt; </span><span style="color:#bf616a;">adj</span><span>[], vector&lt;</span><span style="color:#b48ead;">bool</span><span>&gt;&amp; </span><span style="color:#bf616a;">visited</span><span>)
</span><span>{
</span><span>    queue&lt;</span><span style="color:#b48ead;">int</span><span>&gt; q;
</span><span>    visited[start] = </span><span style="color:#d08770;">true</span><span>;
</span><span>    q.</span><span style="color:#bf616a;">push</span><span>(start);
</span><span>
</span><span>    </span><span style="color:#b48ead;">while</span><span>(!q.</span><span style="color:#bf616a;">empty</span><span>())
</span><span>    {
</span><span>        </span><span style="color:#b48ead;">int</span><span> node = q.</span><span style="color:#bf616a;">front</span><span>();
</span><span>        q.</span><span style="color:#bf616a;">pop</span><span>();
</span><span>        cout &lt;&lt; node &lt;&lt; &quot; &quot;;
</span><span>
</span><span>        </span><span style="color:#b48ead;">for</span><span>(</span><span style="color:#b48ead;">int</span><span> i = </span><span style="color:#d08770;">0</span><span>; i &lt; adj[node].</span><span style="color:#bf616a;">size</span><span>(); i++)
</span><span>        {
</span><span>            </span><span style="color:#b48ead;">int</span><span> neighbor = adj[node][i];
</span><span>            </span><span style="color:#b48ead;">if</span><span>(!visited[neighbor])
</span><span>            {
</span><span>                visited[neighbor] = </span><span style="color:#d08770;">true</span><span>;
</span><span>                q.</span><span style="color:#bf616a;">push</span><span>(neighbor);
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    </span><span style="color:#b48ead;">int</span><span> n, m, v;
</span><span>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; v;
</span><span>    vector&lt;</span><span style="color:#b48ead;">int</span><span>&gt; * adj = </span><span style="color:#b48ead;">new</span><span> vector&lt;</span><span style="color:#b48ead;">int</span><span>&gt;[n+</span><span style="color:#d08770;">1</span><span>];
</span><span>    </span><span style="color:#b48ead;">for</span><span>(</span><span style="color:#b48ead;">int</span><span> i = </span><span style="color:#d08770;">0</span><span>; i &lt; m; i++)
</span><span>    {
</span><span>        </span><span style="color:#b48ead;">int</span><span> u, v;
</span><span>        cin &gt;&gt; u &gt;&gt; v;
</span><span>        adj[u].</span><span style="color:#bf616a;">push_back</span><span>(v);
</span><span>        adj[v].</span><span style="color:#bf616a;">push_back</span><span>(u);
</span><span>    }
</span><span>    </span><span style="color:#b48ead;">for</span><span>(</span><span style="color:#b48ead;">int</span><span> i = </span><span style="color:#d08770;">1</span><span>; i &lt;= n; i++) </span><span style="color:#bf616a;">sort</span><span>(adj[i].</span><span style="color:#bf616a;">begin</span><span>(), adj[i].</span><span style="color:#bf616a;">end</span><span>());
</span><span>
</span><span>    vector&lt;</span><span style="color:#b48ead;">bool</span><span>&gt; </span><span style="color:#bf616a;">visited</span><span>(n+</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">false</span><span>);
</span><span>    </span><span style="color:#bf616a;">dfs</span><span>(v, adj, visited);
</span><span>    cout &lt;&lt; endl;
</span><span>
</span><span>    visited.</span><span style="color:#bf616a;">assign</span><span>(n+</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">false</span><span>);
</span><span>    </span><span style="color:#bf616a;">bfs</span><span>(v, adj, visited);
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<h1 id="ref">ref</h1>
<p><a href="https://www.acmicpc.net/problem/1260">1260번: DFS와 BFS</a></p>

  </div>

	

  <div class="pagination">
  	
		<a href="#" class="top">Top</a>
		
  </div>

  </main>

  
  <footer>
    <span>&copy; 2022 JS970. Made with <a href="https://www.getzola.org">Zola</a> using the <a
          href="https://github.com/aaranxu/tale-zola">Tale-Zola</a> theme.</span>
  </footer>
  
</body>
</html>
